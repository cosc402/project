Created by PLY version 3.8 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> prog
Rule 1     prog -> externs
Rule 2     externs -> <empty>
Rule 3     externs -> externs extern
Rule 4     extern -> dcl ;
Rule 5     extern -> func
Rule 6     dcls -> <empty>
Rule 7     dcls -> dcls dcl ;
Rule 8     dcl -> type dclr
Rule 9     dcl -> dcl , dclr
Rule 10    dclr -> ID
Rule 11    dclr -> ID [ ]
Rule 12    dclr -> ID [ ICON ]
Rule 13    type -> CHAR
Rule 14    type -> FLOAT
Rule 15    type -> DOUBLE
Rule 16    type -> INT
Rule 17    func -> fhead stmts }
Rule 18    fhead -> fname fargs { dcls
Rule 19    fname -> type ID
Rule 20    fname -> ID
Rule 21    fargs -> ( )
Rule 22    fargs -> ( args )
Rule 23    args -> type dclr
Rule 24    args -> args , type dclr
Rule 25    block -> { stmts }
Rule 26    stmts -> <empty>
Rule 27    stmts -> stmts stmt
Rule 28    stmt -> expr ;
Rule 29    stmt -> IF ( cexpr ) stmt
Rule 30    stmt -> IF ( cexpr ) stmt ELSE stmt
Rule 31    stmt -> WHILE ( cexpr ) stmt
Rule 32    stmt -> DO stmt WHILE ( cexpr ) ;
Rule 33    stmt -> FOR ( expro ; cexpro ; expro ) stmt
Rule 34    stmt -> CONTINUE ;
Rule 35    stmt -> BREAK ;
Rule 36    stmt -> RETURN ;
Rule 37    stmt -> RETURN expr ;
Rule 38    stmt -> block
Rule 39    stmt -> ;
Rule 40    cexpro -> <empty>
Rule 41    cexpro -> cexpr
Rule 42    cexpr -> expr EQ expr
Rule 43    cexpr -> expr NEQ expr
Rule 44    cexpr -> expr LEQ expr
Rule 45    cexpr -> expr GEQ expr
Rule 46    cexpr -> expr < expr
Rule 47    cexpr -> expr > expr
Rule 48    cexpr -> cexpr LAND cexpr
Rule 49    cexpr -> cexpr LOR cexpr
Rule 50    cexpr -> ! cexpr
Rule 51    cexpr -> expr
Rule 52    exprs -> expr
Rule 53    exprs -> exprs , expr
Rule 54    expro -> <empty>
Rule 55    expro -> expr
Rule 56    expr -> lval = expr
Rule 57    expr -> lval ADDEQ expr
Rule 58    expr -> lval SUBEQ expr
Rule 59    expr -> lval MULEQ expr
Rule 60    expr -> lval DIVEQ expr
Rule 61    expr -> lval MODEQ expr
Rule 62    expr -> expr + expr
Rule 63    expr -> expr - expr
Rule 64    expr -> expr * expr
Rule 65    expr -> expr / expr
Rule 66    expr -> expr % expr
Rule 67    expr -> expr LSHIFT expr
Rule 68    expr -> expr RSHIFT expr
Rule 69    expr -> & lval
Rule 70    expr -> - expr
Rule 71    expr -> lval
Rule 72    expr -> ID ( )
Rule 73    expr -> ID ( exprs )
Rule 74    expr -> ( expr )
Rule 75    expr -> constant
Rule 76    lval -> ID
Rule 77    lval -> ID [ expr ]
Rule 78    constant -> SCON
Rule 79    constant -> ICON
Rule 80    constant -> CCON
Rule 81    constant -> FCON

Terminals, with rules where they appear

!                    : 50
%                    : 66
&                    : 69
(                    : 21 22 29 30 31 32 33 72 73 74
)                    : 21 22 29 30 31 32 33 72 73 74
*                    : 64
+                    : 62
,                    : 9 24 53
-                    : 63 70
/                    : 65
;                    : 4 7 28 32 33 33 34 35 36 37 39
<                    : 46
=                    : 56
>                    : 47
ADDEQ                : 57
BREAK                : 35
CCON                 : 80
CHAR                 : 13
CONTINUE             : 34
DIVEQ                : 60
DO                   : 32
DOUBLE               : 15
ELSE                 : 30
EQ                   : 42
FCON                 : 81
FLOAT                : 14
FOR                  : 33
GEQ                  : 45
ICON                 : 12 79
ID                   : 10 11 12 19 20 72 73 76 77
IF                   : 29 30
INT                  : 16
LAND                 : 48
LEQ                  : 44
LOR                  : 49
LSHIFT               : 67
MODEQ                : 61
MULEQ                : 59
NEQ                  : 43
RETURN               : 36 37
RSHIFT               : 68
SCON                 : 78
SUBEQ                : 58
WHILE                : 31 32
[                    : 11 12 77
]                    : 11 12 77
error                : 
{                    : 18 25
}                    : 17 25

Nonterminals, with rules where they appear

args                 : 22 24
block                : 38
cexpr                : 29 30 31 32 41 48 48 49 49 50
cexpro               : 33
constant             : 75
dcl                  : 4 7 9
dclr                 : 8 9 23 24
dcls                 : 7 18
expr                 : 28 37 42 42 43 43 44 44 45 45 46 46 47 47 51 52 53 55 56 57 58 59 60 61 62 62 63 63 64 64 65 65 66 66 67 67 68 68 70 74 77
expro                : 33 33
exprs                : 53 73
extern               : 3
externs              : 1 3
fargs                : 18
fhead                : 17
fname                : 18
func                 : 5
lval                 : 56 57 58 59 60 61 69 71
prog                 : 0
stmt                 : 27 29 30 30 31 32 33
stmts                : 17 25 27
type                 : 8 19 23 24

Parsing method: LALR

state 0

    (0) S' -> . prog
    (1) prog -> . externs
    (2) externs -> .
    (3) externs -> . externs extern

    CHAR            reduce using rule 2 (externs -> .)
    FLOAT           reduce using rule 2 (externs -> .)
    DOUBLE          reduce using rule 2 (externs -> .)
    INT             reduce using rule 2 (externs -> .)
    ID              reduce using rule 2 (externs -> .)
    $end            reduce using rule 2 (externs -> .)

    prog                           shift and go to state 1
    externs                        shift and go to state 2

state 1

    (0) S' -> prog .



state 2

    (1) prog -> externs .
    (3) externs -> externs . extern
    (4) extern -> . dcl ;
    (5) extern -> . func
    (8) dcl -> . type dclr
    (9) dcl -> . dcl , dclr
    (17) func -> . fhead stmts }
    (13) type -> . CHAR
    (14) type -> . FLOAT
    (15) type -> . DOUBLE
    (16) type -> . INT
    (18) fhead -> . fname fargs { dcls
    (19) fname -> . type ID
    (20) fname -> . ID

    $end            reduce using rule 1 (prog -> externs .)
    CHAR            shift and go to state 8
    FLOAT           shift and go to state 6
    DOUBLE          shift and go to state 11
    INT             shift and go to state 9
    ID              shift and go to state 7

    fhead                          shift and go to state 3
    dcl                            shift and go to state 4
    fname                          shift and go to state 5
    func                           shift and go to state 10
    extern                         shift and go to state 12
    type                           shift and go to state 13

state 3

    (17) func -> fhead . stmts }
    (26) stmts -> .
    (27) stmts -> . stmts stmt

    }               reduce using rule 26 (stmts -> .)
    IF              reduce using rule 26 (stmts -> .)
    WHILE           reduce using rule 26 (stmts -> .)
    DO              reduce using rule 26 (stmts -> .)
    FOR             reduce using rule 26 (stmts -> .)
    CONTINUE        reduce using rule 26 (stmts -> .)
    BREAK           reduce using rule 26 (stmts -> .)
    RETURN          reduce using rule 26 (stmts -> .)
    ;               reduce using rule 26 (stmts -> .)
    &               reduce using rule 26 (stmts -> .)
    -               reduce using rule 26 (stmts -> .)
    ID              reduce using rule 26 (stmts -> .)
    (               reduce using rule 26 (stmts -> .)
    {               reduce using rule 26 (stmts -> .)
    SCON            reduce using rule 26 (stmts -> .)
    ICON            reduce using rule 26 (stmts -> .)
    CCON            reduce using rule 26 (stmts -> .)
    FCON            reduce using rule 26 (stmts -> .)

    stmts                          shift and go to state 14

state 4

    (4) extern -> dcl . ;
    (9) dcl -> dcl . , dclr

    ;               shift and go to state 15
    ,               shift and go to state 16


state 5

    (18) fhead -> fname . fargs { dcls
    (21) fargs -> . ( )
    (22) fargs -> . ( args )

    (               shift and go to state 18

    fargs                          shift and go to state 17

state 6

    (14) type -> FLOAT .

    ID              reduce using rule 14 (type -> FLOAT .)


state 7

    (20) fname -> ID .

    (               reduce using rule 20 (fname -> ID .)


state 8

    (13) type -> CHAR .

    ID              reduce using rule 13 (type -> CHAR .)


state 9

    (16) type -> INT .

    ID              reduce using rule 16 (type -> INT .)


state 10

    (5) extern -> func .

    CHAR            reduce using rule 5 (extern -> func .)
    FLOAT           reduce using rule 5 (extern -> func .)
    DOUBLE          reduce using rule 5 (extern -> func .)
    INT             reduce using rule 5 (extern -> func .)
    ID              reduce using rule 5 (extern -> func .)
    $end            reduce using rule 5 (extern -> func .)


state 11

    (15) type -> DOUBLE .

    ID              reduce using rule 15 (type -> DOUBLE .)


state 12

    (3) externs -> externs extern .

    CHAR            reduce using rule 3 (externs -> externs extern .)
    FLOAT           reduce using rule 3 (externs -> externs extern .)
    DOUBLE          reduce using rule 3 (externs -> externs extern .)
    INT             reduce using rule 3 (externs -> externs extern .)
    ID              reduce using rule 3 (externs -> externs extern .)
    $end            reduce using rule 3 (externs -> externs extern .)


state 13

    (8) dcl -> type . dclr
    (19) fname -> type . ID
    (10) dclr -> . ID
    (11) dclr -> . ID [ ]
    (12) dclr -> . ID [ ICON ]

    ID              shift and go to state 20

    dclr                           shift and go to state 19

state 14

    (17) func -> fhead stmts . }
    (27) stmts -> stmts . stmt
    (28) stmt -> . expr ;
    (29) stmt -> . IF ( cexpr ) stmt
    (30) stmt -> . IF ( cexpr ) stmt ELSE stmt
    (31) stmt -> . WHILE ( cexpr ) stmt
    (32) stmt -> . DO stmt WHILE ( cexpr ) ;
    (33) stmt -> . FOR ( expro ; cexpro ; expro ) stmt
    (34) stmt -> . CONTINUE ;
    (35) stmt -> . BREAK ;
    (36) stmt -> . RETURN ;
    (37) stmt -> . RETURN expr ;
    (38) stmt -> . block
    (39) stmt -> . ;
    (56) expr -> . lval = expr
    (57) expr -> . lval ADDEQ expr
    (58) expr -> . lval SUBEQ expr
    (59) expr -> . lval MULEQ expr
    (60) expr -> . lval DIVEQ expr
    (61) expr -> . lval MODEQ expr
    (62) expr -> . expr + expr
    (63) expr -> . expr - expr
    (64) expr -> . expr * expr
    (65) expr -> . expr / expr
    (66) expr -> . expr % expr
    (67) expr -> . expr LSHIFT expr
    (68) expr -> . expr RSHIFT expr
    (69) expr -> . & lval
    (70) expr -> . - expr
    (71) expr -> . lval
    (72) expr -> . ID ( )
    (73) expr -> . ID ( exprs )
    (74) expr -> . ( expr )
    (75) expr -> . constant
    (25) block -> . { stmts }
    (76) lval -> . ID
    (77) lval -> . ID [ expr ]
    (78) constant -> . SCON
    (79) constant -> . ICON
    (80) constant -> . CCON
    (81) constant -> . FCON

    }               shift and go to state 42
    IF              shift and go to state 35
    WHILE           shift and go to state 23
    DO              shift and go to state 21
    FOR             shift and go to state 31
    CONTINUE        shift and go to state 38
    BREAK           shift and go to state 37
    RETURN          shift and go to state 22
    ;               shift and go to state 29
    &               shift and go to state 24
    -               shift and go to state 26
    ID              shift and go to state 34
    (               shift and go to state 25
    {               shift and go to state 41
    SCON            shift and go to state 40
    ICON            shift and go to state 30
    CCON            shift and go to state 28
    FCON            shift and go to state 39

    constant                       shift and go to state 27
    expr                           shift and go to state 36
    stmt                           shift and go to state 33
    lval                           shift and go to state 32
    block                          shift and go to state 43

state 15

    (4) extern -> dcl ; .

    CHAR            reduce using rule 4 (extern -> dcl ; .)
    FLOAT           reduce using rule 4 (extern -> dcl ; .)
    DOUBLE          reduce using rule 4 (extern -> dcl ; .)
    INT             reduce using rule 4 (extern -> dcl ; .)
    ID              reduce using rule 4 (extern -> dcl ; .)
    $end            reduce using rule 4 (extern -> dcl ; .)


state 16

    (9) dcl -> dcl , . dclr
    (10) dclr -> . ID
    (11) dclr -> . ID [ ]
    (12) dclr -> . ID [ ICON ]

    ID              shift and go to state 45

    dclr                           shift and go to state 44

state 17

    (18) fhead -> fname fargs . { dcls

    {               shift and go to state 46


state 18

    (21) fargs -> ( . )
    (22) fargs -> ( . args )
    (23) args -> . type dclr
    (24) args -> . args , type dclr
    (13) type -> . CHAR
    (14) type -> . FLOAT
    (15) type -> . DOUBLE
    (16) type -> . INT

    )               shift and go to state 47
    CHAR            shift and go to state 8
    FLOAT           shift and go to state 6
    DOUBLE          shift and go to state 11
    INT             shift and go to state 9

    args                           shift and go to state 48
    type                           shift and go to state 49

state 19

    (8) dcl -> type dclr .

    ;               reduce using rule 8 (dcl -> type dclr .)
    ,               reduce using rule 8 (dcl -> type dclr .)


state 20

    (19) fname -> type ID .
    (10) dclr -> ID .
    (11) dclr -> ID . [ ]
    (12) dclr -> ID . [ ICON ]

    (               reduce using rule 19 (fname -> type ID .)
    ;               reduce using rule 10 (dclr -> ID .)
    ,               reduce using rule 10 (dclr -> ID .)
    [               shift and go to state 50


state 21

    (32) stmt -> DO . stmt WHILE ( cexpr ) ;
    (28) stmt -> . expr ;
    (29) stmt -> . IF ( cexpr ) stmt
    (30) stmt -> . IF ( cexpr ) stmt ELSE stmt
    (31) stmt -> . WHILE ( cexpr ) stmt
    (32) stmt -> . DO stmt WHILE ( cexpr ) ;
    (33) stmt -> . FOR ( expro ; cexpro ; expro ) stmt
    (34) stmt -> . CONTINUE ;
    (35) stmt -> . BREAK ;
    (36) stmt -> . RETURN ;
    (37) stmt -> . RETURN expr ;
    (38) stmt -> . block
    (39) stmt -> . ;
    (56) expr -> . lval = expr
    (57) expr -> . lval ADDEQ expr
    (58) expr -> . lval SUBEQ expr
    (59) expr -> . lval MULEQ expr
    (60) expr -> . lval DIVEQ expr
    (61) expr -> . lval MODEQ expr
    (62) expr -> . expr + expr
    (63) expr -> . expr - expr
    (64) expr -> . expr * expr
    (65) expr -> . expr / expr
    (66) expr -> . expr % expr
    (67) expr -> . expr LSHIFT expr
    (68) expr -> . expr RSHIFT expr
    (69) expr -> . & lval
    (70) expr -> . - expr
    (71) expr -> . lval
    (72) expr -> . ID ( )
    (73) expr -> . ID ( exprs )
    (74) expr -> . ( expr )
    (75) expr -> . constant
    (25) block -> . { stmts }
    (76) lval -> . ID
    (77) lval -> . ID [ expr ]
    (78) constant -> . SCON
    (79) constant -> . ICON
    (80) constant -> . CCON
    (81) constant -> . FCON

    IF              shift and go to state 35
    WHILE           shift and go to state 23
    DO              shift and go to state 21
    FOR             shift and go to state 31
    CONTINUE        shift and go to state 38
    BREAK           shift and go to state 37
    RETURN          shift and go to state 22
    ;               shift and go to state 29
    &               shift and go to state 24
    -               shift and go to state 26
    ID              shift and go to state 34
    (               shift and go to state 25
    {               shift and go to state 41
    SCON            shift and go to state 40
    ICON            shift and go to state 30
    CCON            shift and go to state 28
    FCON            shift and go to state 39

    constant                       shift and go to state 27
    expr                           shift and go to state 36
    stmt                           shift and go to state 51
    lval                           shift and go to state 32
    block                          shift and go to state 43

state 22

    (36) stmt -> RETURN . ;
    (37) stmt -> RETURN . expr ;
    (56) expr -> . lval = expr
    (57) expr -> . lval ADDEQ expr
    (58) expr -> . lval SUBEQ expr
    (59) expr -> . lval MULEQ expr
    (60) expr -> . lval DIVEQ expr
    (61) expr -> . lval MODEQ expr
    (62) expr -> . expr + expr
    (63) expr -> . expr - expr
    (64) expr -> . expr * expr
    (65) expr -> . expr / expr
    (66) expr -> . expr % expr
    (67) expr -> . expr LSHIFT expr
    (68) expr -> . expr RSHIFT expr
    (69) expr -> . & lval
    (70) expr -> . - expr
    (71) expr -> . lval
    (72) expr -> . ID ( )
    (73) expr -> . ID ( exprs )
    (74) expr -> . ( expr )
    (75) expr -> . constant
    (76) lval -> . ID
    (77) lval -> . ID [ expr ]
    (78) constant -> . SCON
    (79) constant -> . ICON
    (80) constant -> . CCON
    (81) constant -> . FCON

    ;               shift and go to state 52
    &               shift and go to state 24
    -               shift and go to state 26
    ID              shift and go to state 34
    (               shift and go to state 25
    SCON            shift and go to state 40
    ICON            shift and go to state 30
    CCON            shift and go to state 28
    FCON            shift and go to state 39

    expr                           shift and go to state 53
    constant                       shift and go to state 27
    lval                           shift and go to state 32

state 23

    (31) stmt -> WHILE . ( cexpr ) stmt

    (               shift and go to state 54


state 24

    (69) expr -> & . lval
    (76) lval -> . ID
    (77) lval -> . ID [ expr ]

    ID              shift and go to state 56

    lval                           shift and go to state 55

state 25

    (74) expr -> ( . expr )
    (56) expr -> . lval = expr
    (57) expr -> . lval ADDEQ expr
    (58) expr -> . lval SUBEQ expr
    (59) expr -> . lval MULEQ expr
    (60) expr -> . lval DIVEQ expr
    (61) expr -> . lval MODEQ expr
    (62) expr -> . expr + expr
    (63) expr -> . expr - expr
    (64) expr -> . expr * expr
    (65) expr -> . expr / expr
    (66) expr -> . expr % expr
    (67) expr -> . expr LSHIFT expr
    (68) expr -> . expr RSHIFT expr
    (69) expr -> . & lval
    (70) expr -> . - expr
    (71) expr -> . lval
    (72) expr -> . ID ( )
    (73) expr -> . ID ( exprs )
    (74) expr -> . ( expr )
    (75) expr -> . constant
    (76) lval -> . ID
    (77) lval -> . ID [ expr ]
    (78) constant -> . SCON
    (79) constant -> . ICON
    (80) constant -> . CCON
    (81) constant -> . FCON

    &               shift and go to state 24
    -               shift and go to state 26
    ID              shift and go to state 34
    (               shift and go to state 25
    SCON            shift and go to state 40
    ICON            shift and go to state 30
    CCON            shift and go to state 28
    FCON            shift and go to state 39

    expr                           shift and go to state 57
    constant                       shift and go to state 27
    lval                           shift and go to state 32

state 26

    (70) expr -> - . expr
    (56) expr -> . lval = expr
    (57) expr -> . lval ADDEQ expr
    (58) expr -> . lval SUBEQ expr
    (59) expr -> . lval MULEQ expr
    (60) expr -> . lval DIVEQ expr
    (61) expr -> . lval MODEQ expr
    (62) expr -> . expr + expr
    (63) expr -> . expr - expr
    (64) expr -> . expr * expr
    (65) expr -> . expr / expr
    (66) expr -> . expr % expr
    (67) expr -> . expr LSHIFT expr
    (68) expr -> . expr RSHIFT expr
    (69) expr -> . & lval
    (70) expr -> . - expr
    (71) expr -> . lval
    (72) expr -> . ID ( )
    (73) expr -> . ID ( exprs )
    (74) expr -> . ( expr )
    (75) expr -> . constant
    (76) lval -> . ID
    (77) lval -> . ID [ expr ]
    (78) constant -> . SCON
    (79) constant -> . ICON
    (80) constant -> . CCON
    (81) constant -> . FCON

    &               shift and go to state 24
    -               shift and go to state 26
    ID              shift and go to state 34
    (               shift and go to state 25
    SCON            shift and go to state 40
    ICON            shift and go to state 30
    CCON            shift and go to state 28
    FCON            shift and go to state 39

    expr                           shift and go to state 58
    constant                       shift and go to state 27
    lval                           shift and go to state 32

state 27

    (75) expr -> constant .

    +               reduce using rule 75 (expr -> constant .)
    -               reduce using rule 75 (expr -> constant .)
    *               reduce using rule 75 (expr -> constant .)
    /               reduce using rule 75 (expr -> constant .)
    %               reduce using rule 75 (expr -> constant .)
    LSHIFT          reduce using rule 75 (expr -> constant .)
    RSHIFT          reduce using rule 75 (expr -> constant .)
    ;               reduce using rule 75 (expr -> constant .)
    )               reduce using rule 75 (expr -> constant .)
    EQ              reduce using rule 75 (expr -> constant .)
    NEQ             reduce using rule 75 (expr -> constant .)
    LEQ             reduce using rule 75 (expr -> constant .)
    GEQ             reduce using rule 75 (expr -> constant .)
    <               reduce using rule 75 (expr -> constant .)
    >               reduce using rule 75 (expr -> constant .)
    LAND            reduce using rule 75 (expr -> constant .)
    LOR             reduce using rule 75 (expr -> constant .)
    ,               reduce using rule 75 (expr -> constant .)
    ]               reduce using rule 75 (expr -> constant .)


state 28

    (80) constant -> CCON .

    EQ              reduce using rule 80 (constant -> CCON .)
    NEQ             reduce using rule 80 (constant -> CCON .)
    LEQ             reduce using rule 80 (constant -> CCON .)
    GEQ             reduce using rule 80 (constant -> CCON .)
    <               reduce using rule 80 (constant -> CCON .)
    >               reduce using rule 80 (constant -> CCON .)
    +               reduce using rule 80 (constant -> CCON .)
    -               reduce using rule 80 (constant -> CCON .)
    *               reduce using rule 80 (constant -> CCON .)
    /               reduce using rule 80 (constant -> CCON .)
    %               reduce using rule 80 (constant -> CCON .)
    LSHIFT          reduce using rule 80 (constant -> CCON .)
    RSHIFT          reduce using rule 80 (constant -> CCON .)
    LAND            reduce using rule 80 (constant -> CCON .)
    LOR             reduce using rule 80 (constant -> CCON .)
    )               reduce using rule 80 (constant -> CCON .)
    ;               reduce using rule 80 (constant -> CCON .)
    ,               reduce using rule 80 (constant -> CCON .)
    ]               reduce using rule 80 (constant -> CCON .)


state 29

    (39) stmt -> ; .

    }               reduce using rule 39 (stmt -> ; .)
    IF              reduce using rule 39 (stmt -> ; .)
    WHILE           reduce using rule 39 (stmt -> ; .)
    DO              reduce using rule 39 (stmt -> ; .)
    FOR             reduce using rule 39 (stmt -> ; .)
    CONTINUE        reduce using rule 39 (stmt -> ; .)
    BREAK           reduce using rule 39 (stmt -> ; .)
    RETURN          reduce using rule 39 (stmt -> ; .)
    ;               reduce using rule 39 (stmt -> ; .)
    &               reduce using rule 39 (stmt -> ; .)
    -               reduce using rule 39 (stmt -> ; .)
    ID              reduce using rule 39 (stmt -> ; .)
    (               reduce using rule 39 (stmt -> ; .)
    {               reduce using rule 39 (stmt -> ; .)
    SCON            reduce using rule 39 (stmt -> ; .)
    ICON            reduce using rule 39 (stmt -> ; .)
    CCON            reduce using rule 39 (stmt -> ; .)
    FCON            reduce using rule 39 (stmt -> ; .)
    ELSE            reduce using rule 39 (stmt -> ; .)


state 30

    (79) constant -> ICON .

    EQ              reduce using rule 79 (constant -> ICON .)
    NEQ             reduce using rule 79 (constant -> ICON .)
    LEQ             reduce using rule 79 (constant -> ICON .)
    GEQ             reduce using rule 79 (constant -> ICON .)
    <               reduce using rule 79 (constant -> ICON .)
    >               reduce using rule 79 (constant -> ICON .)
    +               reduce using rule 79 (constant -> ICON .)
    -               reduce using rule 79 (constant -> ICON .)
    *               reduce using rule 79 (constant -> ICON .)
    /               reduce using rule 79 (constant -> ICON .)
    %               reduce using rule 79 (constant -> ICON .)
    LSHIFT          reduce using rule 79 (constant -> ICON .)
    RSHIFT          reduce using rule 79 (constant -> ICON .)
    LAND            reduce using rule 79 (constant -> ICON .)
    LOR             reduce using rule 79 (constant -> ICON .)
    )               reduce using rule 79 (constant -> ICON .)
    ;               reduce using rule 79 (constant -> ICON .)
    ,               reduce using rule 79 (constant -> ICON .)
    ]               reduce using rule 79 (constant -> ICON .)


state 31

    (33) stmt -> FOR . ( expro ; cexpro ; expro ) stmt

    (               shift and go to state 59


state 32

    (56) expr -> lval . = expr
    (57) expr -> lval . ADDEQ expr
    (58) expr -> lval . SUBEQ expr
    (59) expr -> lval . MULEQ expr
    (60) expr -> lval . DIVEQ expr
    (61) expr -> lval . MODEQ expr
    (71) expr -> lval .

    =               shift and go to state 64
    ADDEQ           shift and go to state 63
    SUBEQ           shift and go to state 61
    MULEQ           shift and go to state 62
    DIVEQ           shift and go to state 65
    MODEQ           shift and go to state 60
    +               reduce using rule 71 (expr -> lval .)
    -               reduce using rule 71 (expr -> lval .)
    *               reduce using rule 71 (expr -> lval .)
    /               reduce using rule 71 (expr -> lval .)
    %               reduce using rule 71 (expr -> lval .)
    LSHIFT          reduce using rule 71 (expr -> lval .)
    RSHIFT          reduce using rule 71 (expr -> lval .)
    ;               reduce using rule 71 (expr -> lval .)
    )               reduce using rule 71 (expr -> lval .)
    EQ              reduce using rule 71 (expr -> lval .)
    NEQ             reduce using rule 71 (expr -> lval .)
    LEQ             reduce using rule 71 (expr -> lval .)
    GEQ             reduce using rule 71 (expr -> lval .)
    <               reduce using rule 71 (expr -> lval .)
    >               reduce using rule 71 (expr -> lval .)
    LAND            reduce using rule 71 (expr -> lval .)
    LOR             reduce using rule 71 (expr -> lval .)
    ,               reduce using rule 71 (expr -> lval .)
    ]               reduce using rule 71 (expr -> lval .)


state 33

    (27) stmts -> stmts stmt .

    }               reduce using rule 27 (stmts -> stmts stmt .)
    IF              reduce using rule 27 (stmts -> stmts stmt .)
    WHILE           reduce using rule 27 (stmts -> stmts stmt .)
    DO              reduce using rule 27 (stmts -> stmts stmt .)
    FOR             reduce using rule 27 (stmts -> stmts stmt .)
    CONTINUE        reduce using rule 27 (stmts -> stmts stmt .)
    BREAK           reduce using rule 27 (stmts -> stmts stmt .)
    RETURN          reduce using rule 27 (stmts -> stmts stmt .)
    ;               reduce using rule 27 (stmts -> stmts stmt .)
    &               reduce using rule 27 (stmts -> stmts stmt .)
    -               reduce using rule 27 (stmts -> stmts stmt .)
    ID              reduce using rule 27 (stmts -> stmts stmt .)
    (               reduce using rule 27 (stmts -> stmts stmt .)
    {               reduce using rule 27 (stmts -> stmts stmt .)
    SCON            reduce using rule 27 (stmts -> stmts stmt .)
    ICON            reduce using rule 27 (stmts -> stmts stmt .)
    CCON            reduce using rule 27 (stmts -> stmts stmt .)
    FCON            reduce using rule 27 (stmts -> stmts stmt .)


state 34

    (72) expr -> ID . ( )
    (73) expr -> ID . ( exprs )
    (76) lval -> ID .
    (77) lval -> ID . [ expr ]

    (               shift and go to state 66
    =               reduce using rule 76 (lval -> ID .)
    ADDEQ           reduce using rule 76 (lval -> ID .)
    SUBEQ           reduce using rule 76 (lval -> ID .)
    MULEQ           reduce using rule 76 (lval -> ID .)
    DIVEQ           reduce using rule 76 (lval -> ID .)
    MODEQ           reduce using rule 76 (lval -> ID .)
    +               reduce using rule 76 (lval -> ID .)
    -               reduce using rule 76 (lval -> ID .)
    *               reduce using rule 76 (lval -> ID .)
    /               reduce using rule 76 (lval -> ID .)
    %               reduce using rule 76 (lval -> ID .)
    LSHIFT          reduce using rule 76 (lval -> ID .)
    RSHIFT          reduce using rule 76 (lval -> ID .)
    ;               reduce using rule 76 (lval -> ID .)
    )               reduce using rule 76 (lval -> ID .)
    EQ              reduce using rule 76 (lval -> ID .)
    NEQ             reduce using rule 76 (lval -> ID .)
    LEQ             reduce using rule 76 (lval -> ID .)
    GEQ             reduce using rule 76 (lval -> ID .)
    <               reduce using rule 76 (lval -> ID .)
    >               reduce using rule 76 (lval -> ID .)
    LAND            reduce using rule 76 (lval -> ID .)
    LOR             reduce using rule 76 (lval -> ID .)
    ,               reduce using rule 76 (lval -> ID .)
    ]               reduce using rule 76 (lval -> ID .)
    [               shift and go to state 67


state 35

    (29) stmt -> IF . ( cexpr ) stmt
    (30) stmt -> IF . ( cexpr ) stmt ELSE stmt

    (               shift and go to state 68


state 36

    (28) stmt -> expr . ;
    (62) expr -> expr . + expr
    (63) expr -> expr . - expr
    (64) expr -> expr . * expr
    (65) expr -> expr . / expr
    (66) expr -> expr . % expr
    (67) expr -> expr . LSHIFT expr
    (68) expr -> expr . RSHIFT expr

    ;               shift and go to state 76
    +               shift and go to state 70
    -               shift and go to state 72
    *               shift and go to state 71
    /               shift and go to state 73
    %               shift and go to state 69
    LSHIFT          shift and go to state 74
    RSHIFT          shift and go to state 75


state 37

    (35) stmt -> BREAK . ;

    ;               shift and go to state 77


state 38

    (34) stmt -> CONTINUE . ;

    ;               shift and go to state 78


state 39

    (81) constant -> FCON .

    EQ              reduce using rule 81 (constant -> FCON .)
    NEQ             reduce using rule 81 (constant -> FCON .)
    LEQ             reduce using rule 81 (constant -> FCON .)
    GEQ             reduce using rule 81 (constant -> FCON .)
    <               reduce using rule 81 (constant -> FCON .)
    >               reduce using rule 81 (constant -> FCON .)
    +               reduce using rule 81 (constant -> FCON .)
    -               reduce using rule 81 (constant -> FCON .)
    *               reduce using rule 81 (constant -> FCON .)
    /               reduce using rule 81 (constant -> FCON .)
    %               reduce using rule 81 (constant -> FCON .)
    LSHIFT          reduce using rule 81 (constant -> FCON .)
    RSHIFT          reduce using rule 81 (constant -> FCON .)
    LAND            reduce using rule 81 (constant -> FCON .)
    LOR             reduce using rule 81 (constant -> FCON .)
    )               reduce using rule 81 (constant -> FCON .)
    ;               reduce using rule 81 (constant -> FCON .)
    ,               reduce using rule 81 (constant -> FCON .)
    ]               reduce using rule 81 (constant -> FCON .)


state 40

    (78) constant -> SCON .

    EQ              reduce using rule 78 (constant -> SCON .)
    NEQ             reduce using rule 78 (constant -> SCON .)
    LEQ             reduce using rule 78 (constant -> SCON .)
    GEQ             reduce using rule 78 (constant -> SCON .)
    <               reduce using rule 78 (constant -> SCON .)
    >               reduce using rule 78 (constant -> SCON .)
    +               reduce using rule 78 (constant -> SCON .)
    -               reduce using rule 78 (constant -> SCON .)
    *               reduce using rule 78 (constant -> SCON .)
    /               reduce using rule 78 (constant -> SCON .)
    %               reduce using rule 78 (constant -> SCON .)
    LSHIFT          reduce using rule 78 (constant -> SCON .)
    RSHIFT          reduce using rule 78 (constant -> SCON .)
    LAND            reduce using rule 78 (constant -> SCON .)
    LOR             reduce using rule 78 (constant -> SCON .)
    )               reduce using rule 78 (constant -> SCON .)
    ;               reduce using rule 78 (constant -> SCON .)
    ,               reduce using rule 78 (constant -> SCON .)
    ]               reduce using rule 78 (constant -> SCON .)


state 41

    (25) block -> { . stmts }
    (26) stmts -> .
    (27) stmts -> . stmts stmt

    }               reduce using rule 26 (stmts -> .)
    IF              reduce using rule 26 (stmts -> .)
    WHILE           reduce using rule 26 (stmts -> .)
    DO              reduce using rule 26 (stmts -> .)
    FOR             reduce using rule 26 (stmts -> .)
    CONTINUE        reduce using rule 26 (stmts -> .)
    BREAK           reduce using rule 26 (stmts -> .)
    RETURN          reduce using rule 26 (stmts -> .)
    ;               reduce using rule 26 (stmts -> .)
    &               reduce using rule 26 (stmts -> .)
    -               reduce using rule 26 (stmts -> .)
    ID              reduce using rule 26 (stmts -> .)
    (               reduce using rule 26 (stmts -> .)
    {               reduce using rule 26 (stmts -> .)
    SCON            reduce using rule 26 (stmts -> .)
    ICON            reduce using rule 26 (stmts -> .)
    CCON            reduce using rule 26 (stmts -> .)
    FCON            reduce using rule 26 (stmts -> .)

    stmts                          shift and go to state 79

state 42

    (17) func -> fhead stmts } .

    CHAR            reduce using rule 17 (func -> fhead stmts } .)
    FLOAT           reduce using rule 17 (func -> fhead stmts } .)
    DOUBLE          reduce using rule 17 (func -> fhead stmts } .)
    INT             reduce using rule 17 (func -> fhead stmts } .)
    ID              reduce using rule 17 (func -> fhead stmts } .)
    $end            reduce using rule 17 (func -> fhead stmts } .)


state 43

    (38) stmt -> block .

    }               reduce using rule 38 (stmt -> block .)
    IF              reduce using rule 38 (stmt -> block .)
    WHILE           reduce using rule 38 (stmt -> block .)
    DO              reduce using rule 38 (stmt -> block .)
    FOR             reduce using rule 38 (stmt -> block .)
    CONTINUE        reduce using rule 38 (stmt -> block .)
    BREAK           reduce using rule 38 (stmt -> block .)
    RETURN          reduce using rule 38 (stmt -> block .)
    ;               reduce using rule 38 (stmt -> block .)
    &               reduce using rule 38 (stmt -> block .)
    -               reduce using rule 38 (stmt -> block .)
    ID              reduce using rule 38 (stmt -> block .)
    (               reduce using rule 38 (stmt -> block .)
    {               reduce using rule 38 (stmt -> block .)
    SCON            reduce using rule 38 (stmt -> block .)
    ICON            reduce using rule 38 (stmt -> block .)
    CCON            reduce using rule 38 (stmt -> block .)
    FCON            reduce using rule 38 (stmt -> block .)
    ELSE            reduce using rule 38 (stmt -> block .)


state 44

    (9) dcl -> dcl , dclr .

    ;               reduce using rule 9 (dcl -> dcl , dclr .)
    ,               reduce using rule 9 (dcl -> dcl , dclr .)


state 45

    (10) dclr -> ID .
    (11) dclr -> ID . [ ]
    (12) dclr -> ID . [ ICON ]

    ;               reduce using rule 10 (dclr -> ID .)
    ,               reduce using rule 10 (dclr -> ID .)
    )               reduce using rule 10 (dclr -> ID .)
    [               shift and go to state 50


state 46

    (18) fhead -> fname fargs { . dcls
    (6) dcls -> .
    (7) dcls -> . dcls dcl ;

    CHAR            reduce using rule 6 (dcls -> .)
    FLOAT           reduce using rule 6 (dcls -> .)
    DOUBLE          reduce using rule 6 (dcls -> .)
    INT             reduce using rule 6 (dcls -> .)
    }               reduce using rule 6 (dcls -> .)
    IF              reduce using rule 6 (dcls -> .)
    WHILE           reduce using rule 6 (dcls -> .)
    DO              reduce using rule 6 (dcls -> .)
    FOR             reduce using rule 6 (dcls -> .)
    CONTINUE        reduce using rule 6 (dcls -> .)
    BREAK           reduce using rule 6 (dcls -> .)
    RETURN          reduce using rule 6 (dcls -> .)
    ;               reduce using rule 6 (dcls -> .)
    &               reduce using rule 6 (dcls -> .)
    -               reduce using rule 6 (dcls -> .)
    ID              reduce using rule 6 (dcls -> .)
    (               reduce using rule 6 (dcls -> .)
    {               reduce using rule 6 (dcls -> .)
    SCON            reduce using rule 6 (dcls -> .)
    ICON            reduce using rule 6 (dcls -> .)
    CCON            reduce using rule 6 (dcls -> .)
    FCON            reduce using rule 6 (dcls -> .)

    dcls                           shift and go to state 80

state 47

    (21) fargs -> ( ) .

    {               reduce using rule 21 (fargs -> ( ) .)


state 48

    (22) fargs -> ( args . )
    (24) args -> args . , type dclr

    )               shift and go to state 81
    ,               shift and go to state 82


state 49

    (23) args -> type . dclr
    (10) dclr -> . ID
    (11) dclr -> . ID [ ]
    (12) dclr -> . ID [ ICON ]

    ID              shift and go to state 45

    dclr                           shift and go to state 83

state 50

    (11) dclr -> ID [ . ]
    (12) dclr -> ID [ . ICON ]

    ]               shift and go to state 84
    ICON            shift and go to state 85


state 51

    (32) stmt -> DO stmt . WHILE ( cexpr ) ;

    WHILE           shift and go to state 86


state 52

    (36) stmt -> RETURN ; .

    }               reduce using rule 36 (stmt -> RETURN ; .)
    IF              reduce using rule 36 (stmt -> RETURN ; .)
    WHILE           reduce using rule 36 (stmt -> RETURN ; .)
    DO              reduce using rule 36 (stmt -> RETURN ; .)
    FOR             reduce using rule 36 (stmt -> RETURN ; .)
    CONTINUE        reduce using rule 36 (stmt -> RETURN ; .)
    BREAK           reduce using rule 36 (stmt -> RETURN ; .)
    RETURN          reduce using rule 36 (stmt -> RETURN ; .)
    ;               reduce using rule 36 (stmt -> RETURN ; .)
    &               reduce using rule 36 (stmt -> RETURN ; .)
    -               reduce using rule 36 (stmt -> RETURN ; .)
    ID              reduce using rule 36 (stmt -> RETURN ; .)
    (               reduce using rule 36 (stmt -> RETURN ; .)
    {               reduce using rule 36 (stmt -> RETURN ; .)
    SCON            reduce using rule 36 (stmt -> RETURN ; .)
    ICON            reduce using rule 36 (stmt -> RETURN ; .)
    CCON            reduce using rule 36 (stmt -> RETURN ; .)
    FCON            reduce using rule 36 (stmt -> RETURN ; .)
    ELSE            reduce using rule 36 (stmt -> RETURN ; .)


state 53

    (37) stmt -> RETURN expr . ;
    (62) expr -> expr . + expr
    (63) expr -> expr . - expr
    (64) expr -> expr . * expr
    (65) expr -> expr . / expr
    (66) expr -> expr . % expr
    (67) expr -> expr . LSHIFT expr
    (68) expr -> expr . RSHIFT expr

    ;               shift and go to state 87
    +               shift and go to state 70
    -               shift and go to state 72
    *               shift and go to state 71
    /               shift and go to state 73
    %               shift and go to state 69
    LSHIFT          shift and go to state 74
    RSHIFT          shift and go to state 75


state 54

    (31) stmt -> WHILE ( . cexpr ) stmt
    (42) cexpr -> . expr EQ expr
    (43) cexpr -> . expr NEQ expr
    (44) cexpr -> . expr LEQ expr
    (45) cexpr -> . expr GEQ expr
    (46) cexpr -> . expr < expr
    (47) cexpr -> . expr > expr
    (48) cexpr -> . cexpr LAND cexpr
    (49) cexpr -> . cexpr LOR cexpr
    (50) cexpr -> . ! cexpr
    (51) cexpr -> . expr
    (56) expr -> . lval = expr
    (57) expr -> . lval ADDEQ expr
    (58) expr -> . lval SUBEQ expr
    (59) expr -> . lval MULEQ expr
    (60) expr -> . lval DIVEQ expr
    (61) expr -> . lval MODEQ expr
    (62) expr -> . expr + expr
    (63) expr -> . expr - expr
    (64) expr -> . expr * expr
    (65) expr -> . expr / expr
    (66) expr -> . expr % expr
    (67) expr -> . expr LSHIFT expr
    (68) expr -> . expr RSHIFT expr
    (69) expr -> . & lval
    (70) expr -> . - expr
    (71) expr -> . lval
    (72) expr -> . ID ( )
    (73) expr -> . ID ( exprs )
    (74) expr -> . ( expr )
    (75) expr -> . constant
    (76) lval -> . ID
    (77) lval -> . ID [ expr ]
    (78) constant -> . SCON
    (79) constant -> . ICON
    (80) constant -> . CCON
    (81) constant -> . FCON

    !               shift and go to state 88
    &               shift and go to state 24
    -               shift and go to state 26
    ID              shift and go to state 34
    (               shift and go to state 25
    SCON            shift and go to state 40
    ICON            shift and go to state 30
    CCON            shift and go to state 28
    FCON            shift and go to state 39

    constant                       shift and go to state 27
    expr                           shift and go to state 90
    lval                           shift and go to state 32
    cexpr                          shift and go to state 89

state 55

    (69) expr -> & lval .

    +               reduce using rule 69 (expr -> & lval .)
    -               reduce using rule 69 (expr -> & lval .)
    *               reduce using rule 69 (expr -> & lval .)
    /               reduce using rule 69 (expr -> & lval .)
    %               reduce using rule 69 (expr -> & lval .)
    LSHIFT          reduce using rule 69 (expr -> & lval .)
    RSHIFT          reduce using rule 69 (expr -> & lval .)
    ;               reduce using rule 69 (expr -> & lval .)
    )               reduce using rule 69 (expr -> & lval .)
    EQ              reduce using rule 69 (expr -> & lval .)
    NEQ             reduce using rule 69 (expr -> & lval .)
    LEQ             reduce using rule 69 (expr -> & lval .)
    GEQ             reduce using rule 69 (expr -> & lval .)
    <               reduce using rule 69 (expr -> & lval .)
    >               reduce using rule 69 (expr -> & lval .)
    LAND            reduce using rule 69 (expr -> & lval .)
    LOR             reduce using rule 69 (expr -> & lval .)
    ,               reduce using rule 69 (expr -> & lval .)
    ]               reduce using rule 69 (expr -> & lval .)


state 56

    (76) lval -> ID .
    (77) lval -> ID . [ expr ]

    ;               reduce using rule 76 (lval -> ID .)
    +               reduce using rule 76 (lval -> ID .)
    -               reduce using rule 76 (lval -> ID .)
    *               reduce using rule 76 (lval -> ID .)
    /               reduce using rule 76 (lval -> ID .)
    %               reduce using rule 76 (lval -> ID .)
    LSHIFT          reduce using rule 76 (lval -> ID .)
    RSHIFT          reduce using rule 76 (lval -> ID .)
    )               reduce using rule 76 (lval -> ID .)
    EQ              reduce using rule 76 (lval -> ID .)
    NEQ             reduce using rule 76 (lval -> ID .)
    LEQ             reduce using rule 76 (lval -> ID .)
    GEQ             reduce using rule 76 (lval -> ID .)
    <               reduce using rule 76 (lval -> ID .)
    >               reduce using rule 76 (lval -> ID .)
    LAND            reduce using rule 76 (lval -> ID .)
    LOR             reduce using rule 76 (lval -> ID .)
    ,               reduce using rule 76 (lval -> ID .)
    ]               reduce using rule 76 (lval -> ID .)
    [               shift and go to state 67


state 57

    (74) expr -> ( expr . )
    (62) expr -> expr . + expr
    (63) expr -> expr . - expr
    (64) expr -> expr . * expr
    (65) expr -> expr . / expr
    (66) expr -> expr . % expr
    (67) expr -> expr . LSHIFT expr
    (68) expr -> expr . RSHIFT expr

    )               shift and go to state 91
    +               shift and go to state 70
    -               shift and go to state 72
    *               shift and go to state 71
    /               shift and go to state 73
    %               shift and go to state 69
    LSHIFT          shift and go to state 74
    RSHIFT          shift and go to state 75


state 58

    (70) expr -> - expr .
    (62) expr -> expr . + expr
    (63) expr -> expr . - expr
    (64) expr -> expr . * expr
    (65) expr -> expr . / expr
    (66) expr -> expr . % expr
    (67) expr -> expr . LSHIFT expr
    (68) expr -> expr . RSHIFT expr

    +               reduce using rule 70 (expr -> - expr .)
    -               reduce using rule 70 (expr -> - expr .)
    *               reduce using rule 70 (expr -> - expr .)
    /               reduce using rule 70 (expr -> - expr .)
    %               reduce using rule 70 (expr -> - expr .)
    LSHIFT          reduce using rule 70 (expr -> - expr .)
    RSHIFT          reduce using rule 70 (expr -> - expr .)
    ;               reduce using rule 70 (expr -> - expr .)
    )               reduce using rule 70 (expr -> - expr .)
    EQ              reduce using rule 70 (expr -> - expr .)
    NEQ             reduce using rule 70 (expr -> - expr .)
    LEQ             reduce using rule 70 (expr -> - expr .)
    GEQ             reduce using rule 70 (expr -> - expr .)
    <               reduce using rule 70 (expr -> - expr .)
    >               reduce using rule 70 (expr -> - expr .)
    LAND            reduce using rule 70 (expr -> - expr .)
    LOR             reduce using rule 70 (expr -> - expr .)
    ,               reduce using rule 70 (expr -> - expr .)
    ]               reduce using rule 70 (expr -> - expr .)

  ! +               [ shift and go to state 70 ]
  ! -               [ shift and go to state 72 ]
  ! *               [ shift and go to state 71 ]
  ! /               [ shift and go to state 73 ]
  ! %               [ shift and go to state 69 ]
  ! LSHIFT          [ shift and go to state 74 ]
  ! RSHIFT          [ shift and go to state 75 ]


state 59

    (33) stmt -> FOR ( . expro ; cexpro ; expro ) stmt
    (54) expro -> .
    (55) expro -> . expr
    (56) expr -> . lval = expr
    (57) expr -> . lval ADDEQ expr
    (58) expr -> . lval SUBEQ expr
    (59) expr -> . lval MULEQ expr
    (60) expr -> . lval DIVEQ expr
    (61) expr -> . lval MODEQ expr
    (62) expr -> . expr + expr
    (63) expr -> . expr - expr
    (64) expr -> . expr * expr
    (65) expr -> . expr / expr
    (66) expr -> . expr % expr
    (67) expr -> . expr LSHIFT expr
    (68) expr -> . expr RSHIFT expr
    (69) expr -> . & lval
    (70) expr -> . - expr
    (71) expr -> . lval
    (72) expr -> . ID ( )
    (73) expr -> . ID ( exprs )
    (74) expr -> . ( expr )
    (75) expr -> . constant
    (76) lval -> . ID
    (77) lval -> . ID [ expr ]
    (78) constant -> . SCON
    (79) constant -> . ICON
    (80) constant -> . CCON
    (81) constant -> . FCON

    ;               reduce using rule 54 (expro -> .)
    &               shift and go to state 24
    -               shift and go to state 26
    ID              shift and go to state 34
    (               shift and go to state 25
    SCON            shift and go to state 40
    ICON            shift and go to state 30
    CCON            shift and go to state 28
    FCON            shift and go to state 39

    constant                       shift and go to state 27
    expr                           shift and go to state 92
    expro                          shift and go to state 93
    lval                           shift and go to state 32

state 60

    (61) expr -> lval MODEQ . expr
    (56) expr -> . lval = expr
    (57) expr -> . lval ADDEQ expr
    (58) expr -> . lval SUBEQ expr
    (59) expr -> . lval MULEQ expr
    (60) expr -> . lval DIVEQ expr
    (61) expr -> . lval MODEQ expr
    (62) expr -> . expr + expr
    (63) expr -> . expr - expr
    (64) expr -> . expr * expr
    (65) expr -> . expr / expr
    (66) expr -> . expr % expr
    (67) expr -> . expr LSHIFT expr
    (68) expr -> . expr RSHIFT expr
    (69) expr -> . & lval
    (70) expr -> . - expr
    (71) expr -> . lval
    (72) expr -> . ID ( )
    (73) expr -> . ID ( exprs )
    (74) expr -> . ( expr )
    (75) expr -> . constant
    (76) lval -> . ID
    (77) lval -> . ID [ expr ]
    (78) constant -> . SCON
    (79) constant -> . ICON
    (80) constant -> . CCON
    (81) constant -> . FCON

    &               shift and go to state 24
    -               shift and go to state 26
    ID              shift and go to state 34
    (               shift and go to state 25
    SCON            shift and go to state 40
    ICON            shift and go to state 30
    CCON            shift and go to state 28
    FCON            shift and go to state 39

    expr                           shift and go to state 94
    constant                       shift and go to state 27
    lval                           shift and go to state 32

state 61

    (58) expr -> lval SUBEQ . expr
    (56) expr -> . lval = expr
    (57) expr -> . lval ADDEQ expr
    (58) expr -> . lval SUBEQ expr
    (59) expr -> . lval MULEQ expr
    (60) expr -> . lval DIVEQ expr
    (61) expr -> . lval MODEQ expr
    (62) expr -> . expr + expr
    (63) expr -> . expr - expr
    (64) expr -> . expr * expr
    (65) expr -> . expr / expr
    (66) expr -> . expr % expr
    (67) expr -> . expr LSHIFT expr
    (68) expr -> . expr RSHIFT expr
    (69) expr -> . & lval
    (70) expr -> . - expr
    (71) expr -> . lval
    (72) expr -> . ID ( )
    (73) expr -> . ID ( exprs )
    (74) expr -> . ( expr )
    (75) expr -> . constant
    (76) lval -> . ID
    (77) lval -> . ID [ expr ]
    (78) constant -> . SCON
    (79) constant -> . ICON
    (80) constant -> . CCON
    (81) constant -> . FCON

    &               shift and go to state 24
    -               shift and go to state 26
    ID              shift and go to state 34
    (               shift and go to state 25
    SCON            shift and go to state 40
    ICON            shift and go to state 30
    CCON            shift and go to state 28
    FCON            shift and go to state 39

    expr                           shift and go to state 95
    constant                       shift and go to state 27
    lval                           shift and go to state 32

state 62

    (59) expr -> lval MULEQ . expr
    (56) expr -> . lval = expr
    (57) expr -> . lval ADDEQ expr
    (58) expr -> . lval SUBEQ expr
    (59) expr -> . lval MULEQ expr
    (60) expr -> . lval DIVEQ expr
    (61) expr -> . lval MODEQ expr
    (62) expr -> . expr + expr
    (63) expr -> . expr - expr
    (64) expr -> . expr * expr
    (65) expr -> . expr / expr
    (66) expr -> . expr % expr
    (67) expr -> . expr LSHIFT expr
    (68) expr -> . expr RSHIFT expr
    (69) expr -> . & lval
    (70) expr -> . - expr
    (71) expr -> . lval
    (72) expr -> . ID ( )
    (73) expr -> . ID ( exprs )
    (74) expr -> . ( expr )
    (75) expr -> . constant
    (76) lval -> . ID
    (77) lval -> . ID [ expr ]
    (78) constant -> . SCON
    (79) constant -> . ICON
    (80) constant -> . CCON
    (81) constant -> . FCON

    &               shift and go to state 24
    -               shift and go to state 26
    ID              shift and go to state 34
    (               shift and go to state 25
    SCON            shift and go to state 40
    ICON            shift and go to state 30
    CCON            shift and go to state 28
    FCON            shift and go to state 39

    expr                           shift and go to state 96
    constant                       shift and go to state 27
    lval                           shift and go to state 32

state 63

    (57) expr -> lval ADDEQ . expr
    (56) expr -> . lval = expr
    (57) expr -> . lval ADDEQ expr
    (58) expr -> . lval SUBEQ expr
    (59) expr -> . lval MULEQ expr
    (60) expr -> . lval DIVEQ expr
    (61) expr -> . lval MODEQ expr
    (62) expr -> . expr + expr
    (63) expr -> . expr - expr
    (64) expr -> . expr * expr
    (65) expr -> . expr / expr
    (66) expr -> . expr % expr
    (67) expr -> . expr LSHIFT expr
    (68) expr -> . expr RSHIFT expr
    (69) expr -> . & lval
    (70) expr -> . - expr
    (71) expr -> . lval
    (72) expr -> . ID ( )
    (73) expr -> . ID ( exprs )
    (74) expr -> . ( expr )
    (75) expr -> . constant
    (76) lval -> . ID
    (77) lval -> . ID [ expr ]
    (78) constant -> . SCON
    (79) constant -> . ICON
    (80) constant -> . CCON
    (81) constant -> . FCON

    &               shift and go to state 24
    -               shift and go to state 26
    ID              shift and go to state 34
    (               shift and go to state 25
    SCON            shift and go to state 40
    ICON            shift and go to state 30
    CCON            shift and go to state 28
    FCON            shift and go to state 39

    expr                           shift and go to state 97
    constant                       shift and go to state 27
    lval                           shift and go to state 32

state 64

    (56) expr -> lval = . expr
    (56) expr -> . lval = expr
    (57) expr -> . lval ADDEQ expr
    (58) expr -> . lval SUBEQ expr
    (59) expr -> . lval MULEQ expr
    (60) expr -> . lval DIVEQ expr
    (61) expr -> . lval MODEQ expr
    (62) expr -> . expr + expr
    (63) expr -> . expr - expr
    (64) expr -> . expr * expr
    (65) expr -> . expr / expr
    (66) expr -> . expr % expr
    (67) expr -> . expr LSHIFT expr
    (68) expr -> . expr RSHIFT expr
    (69) expr -> . & lval
    (70) expr -> . - expr
    (71) expr -> . lval
    (72) expr -> . ID ( )
    (73) expr -> . ID ( exprs )
    (74) expr -> . ( expr )
    (75) expr -> . constant
    (76) lval -> . ID
    (77) lval -> . ID [ expr ]
    (78) constant -> . SCON
    (79) constant -> . ICON
    (80) constant -> . CCON
    (81) constant -> . FCON

    &               shift and go to state 24
    -               shift and go to state 26
    ID              shift and go to state 34
    (               shift and go to state 25
    SCON            shift and go to state 40
    ICON            shift and go to state 30
    CCON            shift and go to state 28
    FCON            shift and go to state 39

    expr                           shift and go to state 98
    constant                       shift and go to state 27
    lval                           shift and go to state 32

state 65

    (60) expr -> lval DIVEQ . expr
    (56) expr -> . lval = expr
    (57) expr -> . lval ADDEQ expr
    (58) expr -> . lval SUBEQ expr
    (59) expr -> . lval MULEQ expr
    (60) expr -> . lval DIVEQ expr
    (61) expr -> . lval MODEQ expr
    (62) expr -> . expr + expr
    (63) expr -> . expr - expr
    (64) expr -> . expr * expr
    (65) expr -> . expr / expr
    (66) expr -> . expr % expr
    (67) expr -> . expr LSHIFT expr
    (68) expr -> . expr RSHIFT expr
    (69) expr -> . & lval
    (70) expr -> . - expr
    (71) expr -> . lval
    (72) expr -> . ID ( )
    (73) expr -> . ID ( exprs )
    (74) expr -> . ( expr )
    (75) expr -> . constant
    (76) lval -> . ID
    (77) lval -> . ID [ expr ]
    (78) constant -> . SCON
    (79) constant -> . ICON
    (80) constant -> . CCON
    (81) constant -> . FCON

    &               shift and go to state 24
    -               shift and go to state 26
    ID              shift and go to state 34
    (               shift and go to state 25
    SCON            shift and go to state 40
    ICON            shift and go to state 30
    CCON            shift and go to state 28
    FCON            shift and go to state 39

    expr                           shift and go to state 99
    constant                       shift and go to state 27
    lval                           shift and go to state 32

state 66

    (72) expr -> ID ( . )
    (73) expr -> ID ( . exprs )
    (52) exprs -> . expr
    (53) exprs -> . exprs , expr
    (56) expr -> . lval = expr
    (57) expr -> . lval ADDEQ expr
    (58) expr -> . lval SUBEQ expr
    (59) expr -> . lval MULEQ expr
    (60) expr -> . lval DIVEQ expr
    (61) expr -> . lval MODEQ expr
    (62) expr -> . expr + expr
    (63) expr -> . expr - expr
    (64) expr -> . expr * expr
    (65) expr -> . expr / expr
    (66) expr -> . expr % expr
    (67) expr -> . expr LSHIFT expr
    (68) expr -> . expr RSHIFT expr
    (69) expr -> . & lval
    (70) expr -> . - expr
    (71) expr -> . lval
    (72) expr -> . ID ( )
    (73) expr -> . ID ( exprs )
    (74) expr -> . ( expr )
    (75) expr -> . constant
    (76) lval -> . ID
    (77) lval -> . ID [ expr ]
    (78) constant -> . SCON
    (79) constant -> . ICON
    (80) constant -> . CCON
    (81) constant -> . FCON

    )               shift and go to state 100
    &               shift and go to state 24
    -               shift and go to state 26
    ID              shift and go to state 34
    (               shift and go to state 25
    SCON            shift and go to state 40
    ICON            shift and go to state 30
    CCON            shift and go to state 28
    FCON            shift and go to state 39

    exprs                          shift and go to state 102
    constant                       shift and go to state 27
    lval                           shift and go to state 32
    expr                           shift and go to state 101

state 67

    (77) lval -> ID [ . expr ]
    (56) expr -> . lval = expr
    (57) expr -> . lval ADDEQ expr
    (58) expr -> . lval SUBEQ expr
    (59) expr -> . lval MULEQ expr
    (60) expr -> . lval DIVEQ expr
    (61) expr -> . lval MODEQ expr
    (62) expr -> . expr + expr
    (63) expr -> . expr - expr
    (64) expr -> . expr * expr
    (65) expr -> . expr / expr
    (66) expr -> . expr % expr
    (67) expr -> . expr LSHIFT expr
    (68) expr -> . expr RSHIFT expr
    (69) expr -> . & lval
    (70) expr -> . - expr
    (71) expr -> . lval
    (72) expr -> . ID ( )
    (73) expr -> . ID ( exprs )
    (74) expr -> . ( expr )
    (75) expr -> . constant
    (76) lval -> . ID
    (77) lval -> . ID [ expr ]
    (78) constant -> . SCON
    (79) constant -> . ICON
    (80) constant -> . CCON
    (81) constant -> . FCON

    &               shift and go to state 24
    -               shift and go to state 26
    ID              shift and go to state 34
    (               shift and go to state 25
    SCON            shift and go to state 40
    ICON            shift and go to state 30
    CCON            shift and go to state 28
    FCON            shift and go to state 39

    expr                           shift and go to state 103
    constant                       shift and go to state 27
    lval                           shift and go to state 32

state 68

    (29) stmt -> IF ( . cexpr ) stmt
    (30) stmt -> IF ( . cexpr ) stmt ELSE stmt
    (42) cexpr -> . expr EQ expr
    (43) cexpr -> . expr NEQ expr
    (44) cexpr -> . expr LEQ expr
    (45) cexpr -> . expr GEQ expr
    (46) cexpr -> . expr < expr
    (47) cexpr -> . expr > expr
    (48) cexpr -> . cexpr LAND cexpr
    (49) cexpr -> . cexpr LOR cexpr
    (50) cexpr -> . ! cexpr
    (51) cexpr -> . expr
    (56) expr -> . lval = expr
    (57) expr -> . lval ADDEQ expr
    (58) expr -> . lval SUBEQ expr
    (59) expr -> . lval MULEQ expr
    (60) expr -> . lval DIVEQ expr
    (61) expr -> . lval MODEQ expr
    (62) expr -> . expr + expr
    (63) expr -> . expr - expr
    (64) expr -> . expr * expr
    (65) expr -> . expr / expr
    (66) expr -> . expr % expr
    (67) expr -> . expr LSHIFT expr
    (68) expr -> . expr RSHIFT expr
    (69) expr -> . & lval
    (70) expr -> . - expr
    (71) expr -> . lval
    (72) expr -> . ID ( )
    (73) expr -> . ID ( exprs )
    (74) expr -> . ( expr )
    (75) expr -> . constant
    (76) lval -> . ID
    (77) lval -> . ID [ expr ]
    (78) constant -> . SCON
    (79) constant -> . ICON
    (80) constant -> . CCON
    (81) constant -> . FCON

    !               shift and go to state 88
    &               shift and go to state 24
    -               shift and go to state 26
    ID              shift and go to state 34
    (               shift and go to state 25
    SCON            shift and go to state 40
    ICON            shift and go to state 30
    CCON            shift and go to state 28
    FCON            shift and go to state 39

    constant                       shift and go to state 27
    expr                           shift and go to state 90
    lval                           shift and go to state 32
    cexpr                          shift and go to state 104

state 69

    (66) expr -> expr % . expr
    (56) expr -> . lval = expr
    (57) expr -> . lval ADDEQ expr
    (58) expr -> . lval SUBEQ expr
    (59) expr -> . lval MULEQ expr
    (60) expr -> . lval DIVEQ expr
    (61) expr -> . lval MODEQ expr
    (62) expr -> . expr + expr
    (63) expr -> . expr - expr
    (64) expr -> . expr * expr
    (65) expr -> . expr / expr
    (66) expr -> . expr % expr
    (67) expr -> . expr LSHIFT expr
    (68) expr -> . expr RSHIFT expr
    (69) expr -> . & lval
    (70) expr -> . - expr
    (71) expr -> . lval
    (72) expr -> . ID ( )
    (73) expr -> . ID ( exprs )
    (74) expr -> . ( expr )
    (75) expr -> . constant
    (76) lval -> . ID
    (77) lval -> . ID [ expr ]
    (78) constant -> . SCON
    (79) constant -> . ICON
    (80) constant -> . CCON
    (81) constant -> . FCON

    &               shift and go to state 24
    -               shift and go to state 26
    ID              shift and go to state 34
    (               shift and go to state 25
    SCON            shift and go to state 40
    ICON            shift and go to state 30
    CCON            shift and go to state 28
    FCON            shift and go to state 39

    expr                           shift and go to state 105
    constant                       shift and go to state 27
    lval                           shift and go to state 32

state 70

    (62) expr -> expr + . expr
    (56) expr -> . lval = expr
    (57) expr -> . lval ADDEQ expr
    (58) expr -> . lval SUBEQ expr
    (59) expr -> . lval MULEQ expr
    (60) expr -> . lval DIVEQ expr
    (61) expr -> . lval MODEQ expr
    (62) expr -> . expr + expr
    (63) expr -> . expr - expr
    (64) expr -> . expr * expr
    (65) expr -> . expr / expr
    (66) expr -> . expr % expr
    (67) expr -> . expr LSHIFT expr
    (68) expr -> . expr RSHIFT expr
    (69) expr -> . & lval
    (70) expr -> . - expr
    (71) expr -> . lval
    (72) expr -> . ID ( )
    (73) expr -> . ID ( exprs )
    (74) expr -> . ( expr )
    (75) expr -> . constant
    (76) lval -> . ID
    (77) lval -> . ID [ expr ]
    (78) constant -> . SCON
    (79) constant -> . ICON
    (80) constant -> . CCON
    (81) constant -> . FCON

    &               shift and go to state 24
    -               shift and go to state 26
    ID              shift and go to state 34
    (               shift and go to state 25
    SCON            shift and go to state 40
    ICON            shift and go to state 30
    CCON            shift and go to state 28
    FCON            shift and go to state 39

    expr                           shift and go to state 106
    constant                       shift and go to state 27
    lval                           shift and go to state 32

state 71

    (64) expr -> expr * . expr
    (56) expr -> . lval = expr
    (57) expr -> . lval ADDEQ expr
    (58) expr -> . lval SUBEQ expr
    (59) expr -> . lval MULEQ expr
    (60) expr -> . lval DIVEQ expr
    (61) expr -> . lval MODEQ expr
    (62) expr -> . expr + expr
    (63) expr -> . expr - expr
    (64) expr -> . expr * expr
    (65) expr -> . expr / expr
    (66) expr -> . expr % expr
    (67) expr -> . expr LSHIFT expr
    (68) expr -> . expr RSHIFT expr
    (69) expr -> . & lval
    (70) expr -> . - expr
    (71) expr -> . lval
    (72) expr -> . ID ( )
    (73) expr -> . ID ( exprs )
    (74) expr -> . ( expr )
    (75) expr -> . constant
    (76) lval -> . ID
    (77) lval -> . ID [ expr ]
    (78) constant -> . SCON
    (79) constant -> . ICON
    (80) constant -> . CCON
    (81) constant -> . FCON

    &               shift and go to state 24
    -               shift and go to state 26
    ID              shift and go to state 34
    (               shift and go to state 25
    SCON            shift and go to state 40
    ICON            shift and go to state 30
    CCON            shift and go to state 28
    FCON            shift and go to state 39

    expr                           shift and go to state 107
    constant                       shift and go to state 27
    lval                           shift and go to state 32

state 72

    (63) expr -> expr - . expr
    (56) expr -> . lval = expr
    (57) expr -> . lval ADDEQ expr
    (58) expr -> . lval SUBEQ expr
    (59) expr -> . lval MULEQ expr
    (60) expr -> . lval DIVEQ expr
    (61) expr -> . lval MODEQ expr
    (62) expr -> . expr + expr
    (63) expr -> . expr - expr
    (64) expr -> . expr * expr
    (65) expr -> . expr / expr
    (66) expr -> . expr % expr
    (67) expr -> . expr LSHIFT expr
    (68) expr -> . expr RSHIFT expr
    (69) expr -> . & lval
    (70) expr -> . - expr
    (71) expr -> . lval
    (72) expr -> . ID ( )
    (73) expr -> . ID ( exprs )
    (74) expr -> . ( expr )
    (75) expr -> . constant
    (76) lval -> . ID
    (77) lval -> . ID [ expr ]
    (78) constant -> . SCON
    (79) constant -> . ICON
    (80) constant -> . CCON
    (81) constant -> . FCON

    &               shift and go to state 24
    -               shift and go to state 26
    ID              shift and go to state 34
    (               shift and go to state 25
    SCON            shift and go to state 40
    ICON            shift and go to state 30
    CCON            shift and go to state 28
    FCON            shift and go to state 39

    expr                           shift and go to state 108
    constant                       shift and go to state 27
    lval                           shift and go to state 32

state 73

    (65) expr -> expr / . expr
    (56) expr -> . lval = expr
    (57) expr -> . lval ADDEQ expr
    (58) expr -> . lval SUBEQ expr
    (59) expr -> . lval MULEQ expr
    (60) expr -> . lval DIVEQ expr
    (61) expr -> . lval MODEQ expr
    (62) expr -> . expr + expr
    (63) expr -> . expr - expr
    (64) expr -> . expr * expr
    (65) expr -> . expr / expr
    (66) expr -> . expr % expr
    (67) expr -> . expr LSHIFT expr
    (68) expr -> . expr RSHIFT expr
    (69) expr -> . & lval
    (70) expr -> . - expr
    (71) expr -> . lval
    (72) expr -> . ID ( )
    (73) expr -> . ID ( exprs )
    (74) expr -> . ( expr )
    (75) expr -> . constant
    (76) lval -> . ID
    (77) lval -> . ID [ expr ]
    (78) constant -> . SCON
    (79) constant -> . ICON
    (80) constant -> . CCON
    (81) constant -> . FCON

    &               shift and go to state 24
    -               shift and go to state 26
    ID              shift and go to state 34
    (               shift and go to state 25
    SCON            shift and go to state 40
    ICON            shift and go to state 30
    CCON            shift and go to state 28
    FCON            shift and go to state 39

    expr                           shift and go to state 109
    constant                       shift and go to state 27
    lval                           shift and go to state 32

state 74

    (67) expr -> expr LSHIFT . expr
    (56) expr -> . lval = expr
    (57) expr -> . lval ADDEQ expr
    (58) expr -> . lval SUBEQ expr
    (59) expr -> . lval MULEQ expr
    (60) expr -> . lval DIVEQ expr
    (61) expr -> . lval MODEQ expr
    (62) expr -> . expr + expr
    (63) expr -> . expr - expr
    (64) expr -> . expr * expr
    (65) expr -> . expr / expr
    (66) expr -> . expr % expr
    (67) expr -> . expr LSHIFT expr
    (68) expr -> . expr RSHIFT expr
    (69) expr -> . & lval
    (70) expr -> . - expr
    (71) expr -> . lval
    (72) expr -> . ID ( )
    (73) expr -> . ID ( exprs )
    (74) expr -> . ( expr )
    (75) expr -> . constant
    (76) lval -> . ID
    (77) lval -> . ID [ expr ]
    (78) constant -> . SCON
    (79) constant -> . ICON
    (80) constant -> . CCON
    (81) constant -> . FCON

    &               shift and go to state 24
    -               shift and go to state 26
    ID              shift and go to state 34
    (               shift and go to state 25
    SCON            shift and go to state 40
    ICON            shift and go to state 30
    CCON            shift and go to state 28
    FCON            shift and go to state 39

    expr                           shift and go to state 110
    constant                       shift and go to state 27
    lval                           shift and go to state 32

state 75

    (68) expr -> expr RSHIFT . expr
    (56) expr -> . lval = expr
    (57) expr -> . lval ADDEQ expr
    (58) expr -> . lval SUBEQ expr
    (59) expr -> . lval MULEQ expr
    (60) expr -> . lval DIVEQ expr
    (61) expr -> . lval MODEQ expr
    (62) expr -> . expr + expr
    (63) expr -> . expr - expr
    (64) expr -> . expr * expr
    (65) expr -> . expr / expr
    (66) expr -> . expr % expr
    (67) expr -> . expr LSHIFT expr
    (68) expr -> . expr RSHIFT expr
    (69) expr -> . & lval
    (70) expr -> . - expr
    (71) expr -> . lval
    (72) expr -> . ID ( )
    (73) expr -> . ID ( exprs )
    (74) expr -> . ( expr )
    (75) expr -> . constant
    (76) lval -> . ID
    (77) lval -> . ID [ expr ]
    (78) constant -> . SCON
    (79) constant -> . ICON
    (80) constant -> . CCON
    (81) constant -> . FCON

    &               shift and go to state 24
    -               shift and go to state 26
    ID              shift and go to state 34
    (               shift and go to state 25
    SCON            shift and go to state 40
    ICON            shift and go to state 30
    CCON            shift and go to state 28
    FCON            shift and go to state 39

    expr                           shift and go to state 111
    constant                       shift and go to state 27
    lval                           shift and go to state 32

state 76

    (28) stmt -> expr ; .

    }               reduce using rule 28 (stmt -> expr ; .)
    IF              reduce using rule 28 (stmt -> expr ; .)
    WHILE           reduce using rule 28 (stmt -> expr ; .)
    DO              reduce using rule 28 (stmt -> expr ; .)
    FOR             reduce using rule 28 (stmt -> expr ; .)
    CONTINUE        reduce using rule 28 (stmt -> expr ; .)
    BREAK           reduce using rule 28 (stmt -> expr ; .)
    RETURN          reduce using rule 28 (stmt -> expr ; .)
    ;               reduce using rule 28 (stmt -> expr ; .)
    &               reduce using rule 28 (stmt -> expr ; .)
    -               reduce using rule 28 (stmt -> expr ; .)
    ID              reduce using rule 28 (stmt -> expr ; .)
    (               reduce using rule 28 (stmt -> expr ; .)
    {               reduce using rule 28 (stmt -> expr ; .)
    SCON            reduce using rule 28 (stmt -> expr ; .)
    ICON            reduce using rule 28 (stmt -> expr ; .)
    CCON            reduce using rule 28 (stmt -> expr ; .)
    FCON            reduce using rule 28 (stmt -> expr ; .)
    ELSE            reduce using rule 28 (stmt -> expr ; .)


state 77

    (35) stmt -> BREAK ; .

    }               reduce using rule 35 (stmt -> BREAK ; .)
    IF              reduce using rule 35 (stmt -> BREAK ; .)
    WHILE           reduce using rule 35 (stmt -> BREAK ; .)
    DO              reduce using rule 35 (stmt -> BREAK ; .)
    FOR             reduce using rule 35 (stmt -> BREAK ; .)
    CONTINUE        reduce using rule 35 (stmt -> BREAK ; .)
    BREAK           reduce using rule 35 (stmt -> BREAK ; .)
    RETURN          reduce using rule 35 (stmt -> BREAK ; .)
    ;               reduce using rule 35 (stmt -> BREAK ; .)
    &               reduce using rule 35 (stmt -> BREAK ; .)
    -               reduce using rule 35 (stmt -> BREAK ; .)
    ID              reduce using rule 35 (stmt -> BREAK ; .)
    (               reduce using rule 35 (stmt -> BREAK ; .)
    {               reduce using rule 35 (stmt -> BREAK ; .)
    SCON            reduce using rule 35 (stmt -> BREAK ; .)
    ICON            reduce using rule 35 (stmt -> BREAK ; .)
    CCON            reduce using rule 35 (stmt -> BREAK ; .)
    FCON            reduce using rule 35 (stmt -> BREAK ; .)
    ELSE            reduce using rule 35 (stmt -> BREAK ; .)


state 78

    (34) stmt -> CONTINUE ; .

    }               reduce using rule 34 (stmt -> CONTINUE ; .)
    IF              reduce using rule 34 (stmt -> CONTINUE ; .)
    WHILE           reduce using rule 34 (stmt -> CONTINUE ; .)
    DO              reduce using rule 34 (stmt -> CONTINUE ; .)
    FOR             reduce using rule 34 (stmt -> CONTINUE ; .)
    CONTINUE        reduce using rule 34 (stmt -> CONTINUE ; .)
    BREAK           reduce using rule 34 (stmt -> CONTINUE ; .)
    RETURN          reduce using rule 34 (stmt -> CONTINUE ; .)
    ;               reduce using rule 34 (stmt -> CONTINUE ; .)
    &               reduce using rule 34 (stmt -> CONTINUE ; .)
    -               reduce using rule 34 (stmt -> CONTINUE ; .)
    ID              reduce using rule 34 (stmt -> CONTINUE ; .)
    (               reduce using rule 34 (stmt -> CONTINUE ; .)
    {               reduce using rule 34 (stmt -> CONTINUE ; .)
    SCON            reduce using rule 34 (stmt -> CONTINUE ; .)
    ICON            reduce using rule 34 (stmt -> CONTINUE ; .)
    CCON            reduce using rule 34 (stmt -> CONTINUE ; .)
    FCON            reduce using rule 34 (stmt -> CONTINUE ; .)
    ELSE            reduce using rule 34 (stmt -> CONTINUE ; .)


state 79

    (25) block -> { stmts . }
    (27) stmts -> stmts . stmt
    (28) stmt -> . expr ;
    (29) stmt -> . IF ( cexpr ) stmt
    (30) stmt -> . IF ( cexpr ) stmt ELSE stmt
    (31) stmt -> . WHILE ( cexpr ) stmt
    (32) stmt -> . DO stmt WHILE ( cexpr ) ;
    (33) stmt -> . FOR ( expro ; cexpro ; expro ) stmt
    (34) stmt -> . CONTINUE ;
    (35) stmt -> . BREAK ;
    (36) stmt -> . RETURN ;
    (37) stmt -> . RETURN expr ;
    (38) stmt -> . block
    (39) stmt -> . ;
    (56) expr -> . lval = expr
    (57) expr -> . lval ADDEQ expr
    (58) expr -> . lval SUBEQ expr
    (59) expr -> . lval MULEQ expr
    (60) expr -> . lval DIVEQ expr
    (61) expr -> . lval MODEQ expr
    (62) expr -> . expr + expr
    (63) expr -> . expr - expr
    (64) expr -> . expr * expr
    (65) expr -> . expr / expr
    (66) expr -> . expr % expr
    (67) expr -> . expr LSHIFT expr
    (68) expr -> . expr RSHIFT expr
    (69) expr -> . & lval
    (70) expr -> . - expr
    (71) expr -> . lval
    (72) expr -> . ID ( )
    (73) expr -> . ID ( exprs )
    (74) expr -> . ( expr )
    (75) expr -> . constant
    (25) block -> . { stmts }
    (76) lval -> . ID
    (77) lval -> . ID [ expr ]
    (78) constant -> . SCON
    (79) constant -> . ICON
    (80) constant -> . CCON
    (81) constant -> . FCON

    }               shift and go to state 112
    IF              shift and go to state 35
    WHILE           shift and go to state 23
    DO              shift and go to state 21
    FOR             shift and go to state 31
    CONTINUE        shift and go to state 38
    BREAK           shift and go to state 37
    RETURN          shift and go to state 22
    ;               shift and go to state 29
    &               shift and go to state 24
    -               shift and go to state 26
    ID              shift and go to state 34
    (               shift and go to state 25
    {               shift and go to state 41
    SCON            shift and go to state 40
    ICON            shift and go to state 30
    CCON            shift and go to state 28
    FCON            shift and go to state 39

    constant                       shift and go to state 27
    expr                           shift and go to state 36
    stmt                           shift and go to state 33
    lval                           shift and go to state 32
    block                          shift and go to state 43

state 80

    (18) fhead -> fname fargs { dcls .
    (7) dcls -> dcls . dcl ;
    (8) dcl -> . type dclr
    (9) dcl -> . dcl , dclr
    (13) type -> . CHAR
    (14) type -> . FLOAT
    (15) type -> . DOUBLE
    (16) type -> . INT

    }               reduce using rule 18 (fhead -> fname fargs { dcls .)
    IF              reduce using rule 18 (fhead -> fname fargs { dcls .)
    WHILE           reduce using rule 18 (fhead -> fname fargs { dcls .)
    DO              reduce using rule 18 (fhead -> fname fargs { dcls .)
    FOR             reduce using rule 18 (fhead -> fname fargs { dcls .)
    CONTINUE        reduce using rule 18 (fhead -> fname fargs { dcls .)
    BREAK           reduce using rule 18 (fhead -> fname fargs { dcls .)
    RETURN          reduce using rule 18 (fhead -> fname fargs { dcls .)
    ;               reduce using rule 18 (fhead -> fname fargs { dcls .)
    &               reduce using rule 18 (fhead -> fname fargs { dcls .)
    -               reduce using rule 18 (fhead -> fname fargs { dcls .)
    ID              reduce using rule 18 (fhead -> fname fargs { dcls .)
    (               reduce using rule 18 (fhead -> fname fargs { dcls .)
    {               reduce using rule 18 (fhead -> fname fargs { dcls .)
    SCON            reduce using rule 18 (fhead -> fname fargs { dcls .)
    ICON            reduce using rule 18 (fhead -> fname fargs { dcls .)
    CCON            reduce using rule 18 (fhead -> fname fargs { dcls .)
    FCON            reduce using rule 18 (fhead -> fname fargs { dcls .)
    CHAR            shift and go to state 8
    FLOAT           shift and go to state 6
    DOUBLE          shift and go to state 11
    INT             shift and go to state 9

    dcl                            shift and go to state 113
    type                           shift and go to state 114

state 81

    (22) fargs -> ( args ) .

    {               reduce using rule 22 (fargs -> ( args ) .)


state 82

    (24) args -> args , . type dclr
    (13) type -> . CHAR
    (14) type -> . FLOAT
    (15) type -> . DOUBLE
    (16) type -> . INT

    CHAR            shift and go to state 8
    FLOAT           shift and go to state 6
    DOUBLE          shift and go to state 11
    INT             shift and go to state 9

    type                           shift and go to state 115

state 83

    (23) args -> type dclr .

    )               reduce using rule 23 (args -> type dclr .)
    ,               reduce using rule 23 (args -> type dclr .)


state 84

    (11) dclr -> ID [ ] .

    ;               reduce using rule 11 (dclr -> ID [ ] .)
    ,               reduce using rule 11 (dclr -> ID [ ] .)
    )               reduce using rule 11 (dclr -> ID [ ] .)


state 85

    (12) dclr -> ID [ ICON . ]

    ]               shift and go to state 116


state 86

    (32) stmt -> DO stmt WHILE . ( cexpr ) ;

    (               shift and go to state 117


state 87

    (37) stmt -> RETURN expr ; .

    }               reduce using rule 37 (stmt -> RETURN expr ; .)
    IF              reduce using rule 37 (stmt -> RETURN expr ; .)
    WHILE           reduce using rule 37 (stmt -> RETURN expr ; .)
    DO              reduce using rule 37 (stmt -> RETURN expr ; .)
    FOR             reduce using rule 37 (stmt -> RETURN expr ; .)
    CONTINUE        reduce using rule 37 (stmt -> RETURN expr ; .)
    BREAK           reduce using rule 37 (stmt -> RETURN expr ; .)
    RETURN          reduce using rule 37 (stmt -> RETURN expr ; .)
    ;               reduce using rule 37 (stmt -> RETURN expr ; .)
    &               reduce using rule 37 (stmt -> RETURN expr ; .)
    -               reduce using rule 37 (stmt -> RETURN expr ; .)
    ID              reduce using rule 37 (stmt -> RETURN expr ; .)
    (               reduce using rule 37 (stmt -> RETURN expr ; .)
    {               reduce using rule 37 (stmt -> RETURN expr ; .)
    SCON            reduce using rule 37 (stmt -> RETURN expr ; .)
    ICON            reduce using rule 37 (stmt -> RETURN expr ; .)
    CCON            reduce using rule 37 (stmt -> RETURN expr ; .)
    FCON            reduce using rule 37 (stmt -> RETURN expr ; .)
    ELSE            reduce using rule 37 (stmt -> RETURN expr ; .)


state 88

    (50) cexpr -> ! . cexpr
    (42) cexpr -> . expr EQ expr
    (43) cexpr -> . expr NEQ expr
    (44) cexpr -> . expr LEQ expr
    (45) cexpr -> . expr GEQ expr
    (46) cexpr -> . expr < expr
    (47) cexpr -> . expr > expr
    (48) cexpr -> . cexpr LAND cexpr
    (49) cexpr -> . cexpr LOR cexpr
    (50) cexpr -> . ! cexpr
    (51) cexpr -> . expr
    (56) expr -> . lval = expr
    (57) expr -> . lval ADDEQ expr
    (58) expr -> . lval SUBEQ expr
    (59) expr -> . lval MULEQ expr
    (60) expr -> . lval DIVEQ expr
    (61) expr -> . lval MODEQ expr
    (62) expr -> . expr + expr
    (63) expr -> . expr - expr
    (64) expr -> . expr * expr
    (65) expr -> . expr / expr
    (66) expr -> . expr % expr
    (67) expr -> . expr LSHIFT expr
    (68) expr -> . expr RSHIFT expr
    (69) expr -> . & lval
    (70) expr -> . - expr
    (71) expr -> . lval
    (72) expr -> . ID ( )
    (73) expr -> . ID ( exprs )
    (74) expr -> . ( expr )
    (75) expr -> . constant
    (76) lval -> . ID
    (77) lval -> . ID [ expr ]
    (78) constant -> . SCON
    (79) constant -> . ICON
    (80) constant -> . CCON
    (81) constant -> . FCON

    !               shift and go to state 88
    &               shift and go to state 24
    -               shift and go to state 26
    ID              shift and go to state 34
    (               shift and go to state 25
    SCON            shift and go to state 40
    ICON            shift and go to state 30
    CCON            shift and go to state 28
    FCON            shift and go to state 39

    expr                           shift and go to state 90
    cexpr                          shift and go to state 118
    constant                       shift and go to state 27
    lval                           shift and go to state 32

state 89

    (31) stmt -> WHILE ( cexpr . ) stmt
    (48) cexpr -> cexpr . LAND cexpr
    (49) cexpr -> cexpr . LOR cexpr

    )               shift and go to state 120
    LAND            shift and go to state 119
    LOR             shift and go to state 121


state 90

    (42) cexpr -> expr . EQ expr
    (43) cexpr -> expr . NEQ expr
    (44) cexpr -> expr . LEQ expr
    (45) cexpr -> expr . GEQ expr
    (46) cexpr -> expr . < expr
    (47) cexpr -> expr . > expr
    (51) cexpr -> expr .
    (62) expr -> expr . + expr
    (63) expr -> expr . - expr
    (64) expr -> expr . * expr
    (65) expr -> expr . / expr
    (66) expr -> expr . % expr
    (67) expr -> expr . LSHIFT expr
    (68) expr -> expr . RSHIFT expr

    EQ              shift and go to state 125
    NEQ             shift and go to state 127
    LEQ             shift and go to state 123
    GEQ             shift and go to state 122
    <               shift and go to state 126
    >               shift and go to state 124
    LAND            reduce using rule 51 (cexpr -> expr .)
    LOR             reduce using rule 51 (cexpr -> expr .)
    )               reduce using rule 51 (cexpr -> expr .)
    ;               reduce using rule 51 (cexpr -> expr .)
    +               shift and go to state 70
    -               shift and go to state 72
    *               shift and go to state 71
    /               shift and go to state 73
    %               shift and go to state 69
    LSHIFT          shift and go to state 74
    RSHIFT          shift and go to state 75


state 91

    (74) expr -> ( expr ) .

    +               reduce using rule 74 (expr -> ( expr ) .)
    -               reduce using rule 74 (expr -> ( expr ) .)
    *               reduce using rule 74 (expr -> ( expr ) .)
    /               reduce using rule 74 (expr -> ( expr ) .)
    %               reduce using rule 74 (expr -> ( expr ) .)
    LSHIFT          reduce using rule 74 (expr -> ( expr ) .)
    RSHIFT          reduce using rule 74 (expr -> ( expr ) .)
    ;               reduce using rule 74 (expr -> ( expr ) .)
    )               reduce using rule 74 (expr -> ( expr ) .)
    EQ              reduce using rule 74 (expr -> ( expr ) .)
    NEQ             reduce using rule 74 (expr -> ( expr ) .)
    LEQ             reduce using rule 74 (expr -> ( expr ) .)
    GEQ             reduce using rule 74 (expr -> ( expr ) .)
    <               reduce using rule 74 (expr -> ( expr ) .)
    >               reduce using rule 74 (expr -> ( expr ) .)
    LAND            reduce using rule 74 (expr -> ( expr ) .)
    LOR             reduce using rule 74 (expr -> ( expr ) .)
    ,               reduce using rule 74 (expr -> ( expr ) .)
    ]               reduce using rule 74 (expr -> ( expr ) .)


state 92

    (55) expro -> expr .
    (62) expr -> expr . + expr
    (63) expr -> expr . - expr
    (64) expr -> expr . * expr
    (65) expr -> expr . / expr
    (66) expr -> expr . % expr
    (67) expr -> expr . LSHIFT expr
    (68) expr -> expr . RSHIFT expr

    ;               reduce using rule 55 (expro -> expr .)
    )               reduce using rule 55 (expro -> expr .)
    +               shift and go to state 70
    -               shift and go to state 72
    *               shift and go to state 71
    /               shift and go to state 73
    %               shift and go to state 69
    LSHIFT          shift and go to state 74
    RSHIFT          shift and go to state 75


state 93

    (33) stmt -> FOR ( expro . ; cexpro ; expro ) stmt

    ;               shift and go to state 128


state 94

    (61) expr -> lval MODEQ expr .
    (62) expr -> expr . + expr
    (63) expr -> expr . - expr
    (64) expr -> expr . * expr
    (65) expr -> expr . / expr
    (66) expr -> expr . % expr
    (67) expr -> expr . LSHIFT expr
    (68) expr -> expr . RSHIFT expr

    ;               reduce using rule 61 (expr -> lval MODEQ expr .)
    )               reduce using rule 61 (expr -> lval MODEQ expr .)
    EQ              reduce using rule 61 (expr -> lval MODEQ expr .)
    NEQ             reduce using rule 61 (expr -> lval MODEQ expr .)
    LEQ             reduce using rule 61 (expr -> lval MODEQ expr .)
    GEQ             reduce using rule 61 (expr -> lval MODEQ expr .)
    <               reduce using rule 61 (expr -> lval MODEQ expr .)
    >               reduce using rule 61 (expr -> lval MODEQ expr .)
    LAND            reduce using rule 61 (expr -> lval MODEQ expr .)
    LOR             reduce using rule 61 (expr -> lval MODEQ expr .)
    ,               reduce using rule 61 (expr -> lval MODEQ expr .)
    ]               reduce using rule 61 (expr -> lval MODEQ expr .)
    +               shift and go to state 70
    -               shift and go to state 72
    *               shift and go to state 71
    /               shift and go to state 73
    %               shift and go to state 69
    LSHIFT          shift and go to state 74
    RSHIFT          shift and go to state 75

  ! +               [ reduce using rule 61 (expr -> lval MODEQ expr .) ]
  ! -               [ reduce using rule 61 (expr -> lval MODEQ expr .) ]
  ! *               [ reduce using rule 61 (expr -> lval MODEQ expr .) ]
  ! /               [ reduce using rule 61 (expr -> lval MODEQ expr .) ]
  ! %               [ reduce using rule 61 (expr -> lval MODEQ expr .) ]
  ! LSHIFT          [ reduce using rule 61 (expr -> lval MODEQ expr .) ]
  ! RSHIFT          [ reduce using rule 61 (expr -> lval MODEQ expr .) ]


state 95

    (58) expr -> lval SUBEQ expr .
    (62) expr -> expr . + expr
    (63) expr -> expr . - expr
    (64) expr -> expr . * expr
    (65) expr -> expr . / expr
    (66) expr -> expr . % expr
    (67) expr -> expr . LSHIFT expr
    (68) expr -> expr . RSHIFT expr

    ;               reduce using rule 58 (expr -> lval SUBEQ expr .)
    )               reduce using rule 58 (expr -> lval SUBEQ expr .)
    EQ              reduce using rule 58 (expr -> lval SUBEQ expr .)
    NEQ             reduce using rule 58 (expr -> lval SUBEQ expr .)
    LEQ             reduce using rule 58 (expr -> lval SUBEQ expr .)
    GEQ             reduce using rule 58 (expr -> lval SUBEQ expr .)
    <               reduce using rule 58 (expr -> lval SUBEQ expr .)
    >               reduce using rule 58 (expr -> lval SUBEQ expr .)
    LAND            reduce using rule 58 (expr -> lval SUBEQ expr .)
    LOR             reduce using rule 58 (expr -> lval SUBEQ expr .)
    ,               reduce using rule 58 (expr -> lval SUBEQ expr .)
    ]               reduce using rule 58 (expr -> lval SUBEQ expr .)
    +               shift and go to state 70
    -               shift and go to state 72
    *               shift and go to state 71
    /               shift and go to state 73
    %               shift and go to state 69
    LSHIFT          shift and go to state 74
    RSHIFT          shift and go to state 75

  ! +               [ reduce using rule 58 (expr -> lval SUBEQ expr .) ]
  ! -               [ reduce using rule 58 (expr -> lval SUBEQ expr .) ]
  ! *               [ reduce using rule 58 (expr -> lval SUBEQ expr .) ]
  ! /               [ reduce using rule 58 (expr -> lval SUBEQ expr .) ]
  ! %               [ reduce using rule 58 (expr -> lval SUBEQ expr .) ]
  ! LSHIFT          [ reduce using rule 58 (expr -> lval SUBEQ expr .) ]
  ! RSHIFT          [ reduce using rule 58 (expr -> lval SUBEQ expr .) ]


state 96

    (59) expr -> lval MULEQ expr .
    (62) expr -> expr . + expr
    (63) expr -> expr . - expr
    (64) expr -> expr . * expr
    (65) expr -> expr . / expr
    (66) expr -> expr . % expr
    (67) expr -> expr . LSHIFT expr
    (68) expr -> expr . RSHIFT expr

    ;               reduce using rule 59 (expr -> lval MULEQ expr .)
    )               reduce using rule 59 (expr -> lval MULEQ expr .)
    EQ              reduce using rule 59 (expr -> lval MULEQ expr .)
    NEQ             reduce using rule 59 (expr -> lval MULEQ expr .)
    LEQ             reduce using rule 59 (expr -> lval MULEQ expr .)
    GEQ             reduce using rule 59 (expr -> lval MULEQ expr .)
    <               reduce using rule 59 (expr -> lval MULEQ expr .)
    >               reduce using rule 59 (expr -> lval MULEQ expr .)
    LAND            reduce using rule 59 (expr -> lval MULEQ expr .)
    LOR             reduce using rule 59 (expr -> lval MULEQ expr .)
    ,               reduce using rule 59 (expr -> lval MULEQ expr .)
    ]               reduce using rule 59 (expr -> lval MULEQ expr .)
    +               shift and go to state 70
    -               shift and go to state 72
    *               shift and go to state 71
    /               shift and go to state 73
    %               shift and go to state 69
    LSHIFT          shift and go to state 74
    RSHIFT          shift and go to state 75

  ! +               [ reduce using rule 59 (expr -> lval MULEQ expr .) ]
  ! -               [ reduce using rule 59 (expr -> lval MULEQ expr .) ]
  ! *               [ reduce using rule 59 (expr -> lval MULEQ expr .) ]
  ! /               [ reduce using rule 59 (expr -> lval MULEQ expr .) ]
  ! %               [ reduce using rule 59 (expr -> lval MULEQ expr .) ]
  ! LSHIFT          [ reduce using rule 59 (expr -> lval MULEQ expr .) ]
  ! RSHIFT          [ reduce using rule 59 (expr -> lval MULEQ expr .) ]


state 97

    (57) expr -> lval ADDEQ expr .
    (62) expr -> expr . + expr
    (63) expr -> expr . - expr
    (64) expr -> expr . * expr
    (65) expr -> expr . / expr
    (66) expr -> expr . % expr
    (67) expr -> expr . LSHIFT expr
    (68) expr -> expr . RSHIFT expr

    ;               reduce using rule 57 (expr -> lval ADDEQ expr .)
    )               reduce using rule 57 (expr -> lval ADDEQ expr .)
    EQ              reduce using rule 57 (expr -> lval ADDEQ expr .)
    NEQ             reduce using rule 57 (expr -> lval ADDEQ expr .)
    LEQ             reduce using rule 57 (expr -> lval ADDEQ expr .)
    GEQ             reduce using rule 57 (expr -> lval ADDEQ expr .)
    <               reduce using rule 57 (expr -> lval ADDEQ expr .)
    >               reduce using rule 57 (expr -> lval ADDEQ expr .)
    LAND            reduce using rule 57 (expr -> lval ADDEQ expr .)
    LOR             reduce using rule 57 (expr -> lval ADDEQ expr .)
    ,               reduce using rule 57 (expr -> lval ADDEQ expr .)
    ]               reduce using rule 57 (expr -> lval ADDEQ expr .)
    +               shift and go to state 70
    -               shift and go to state 72
    *               shift and go to state 71
    /               shift and go to state 73
    %               shift and go to state 69
    LSHIFT          shift and go to state 74
    RSHIFT          shift and go to state 75

  ! +               [ reduce using rule 57 (expr -> lval ADDEQ expr .) ]
  ! -               [ reduce using rule 57 (expr -> lval ADDEQ expr .) ]
  ! *               [ reduce using rule 57 (expr -> lval ADDEQ expr .) ]
  ! /               [ reduce using rule 57 (expr -> lval ADDEQ expr .) ]
  ! %               [ reduce using rule 57 (expr -> lval ADDEQ expr .) ]
  ! LSHIFT          [ reduce using rule 57 (expr -> lval ADDEQ expr .) ]
  ! RSHIFT          [ reduce using rule 57 (expr -> lval ADDEQ expr .) ]


state 98

    (56) expr -> lval = expr .
    (62) expr -> expr . + expr
    (63) expr -> expr . - expr
    (64) expr -> expr . * expr
    (65) expr -> expr . / expr
    (66) expr -> expr . % expr
    (67) expr -> expr . LSHIFT expr
    (68) expr -> expr . RSHIFT expr

    ;               reduce using rule 56 (expr -> lval = expr .)
    )               reduce using rule 56 (expr -> lval = expr .)
    EQ              reduce using rule 56 (expr -> lval = expr .)
    NEQ             reduce using rule 56 (expr -> lval = expr .)
    LEQ             reduce using rule 56 (expr -> lval = expr .)
    GEQ             reduce using rule 56 (expr -> lval = expr .)
    <               reduce using rule 56 (expr -> lval = expr .)
    >               reduce using rule 56 (expr -> lval = expr .)
    LAND            reduce using rule 56 (expr -> lval = expr .)
    LOR             reduce using rule 56 (expr -> lval = expr .)
    ,               reduce using rule 56 (expr -> lval = expr .)
    ]               reduce using rule 56 (expr -> lval = expr .)
    +               shift and go to state 70
    -               shift and go to state 72
    *               shift and go to state 71
    /               shift and go to state 73
    %               shift and go to state 69
    LSHIFT          shift and go to state 74
    RSHIFT          shift and go to state 75

  ! +               [ reduce using rule 56 (expr -> lval = expr .) ]
  ! -               [ reduce using rule 56 (expr -> lval = expr .) ]
  ! *               [ reduce using rule 56 (expr -> lval = expr .) ]
  ! /               [ reduce using rule 56 (expr -> lval = expr .) ]
  ! %               [ reduce using rule 56 (expr -> lval = expr .) ]
  ! LSHIFT          [ reduce using rule 56 (expr -> lval = expr .) ]
  ! RSHIFT          [ reduce using rule 56 (expr -> lval = expr .) ]


state 99

    (60) expr -> lval DIVEQ expr .
    (62) expr -> expr . + expr
    (63) expr -> expr . - expr
    (64) expr -> expr . * expr
    (65) expr -> expr . / expr
    (66) expr -> expr . % expr
    (67) expr -> expr . LSHIFT expr
    (68) expr -> expr . RSHIFT expr

    ;               reduce using rule 60 (expr -> lval DIVEQ expr .)
    )               reduce using rule 60 (expr -> lval DIVEQ expr .)
    EQ              reduce using rule 60 (expr -> lval DIVEQ expr .)
    NEQ             reduce using rule 60 (expr -> lval DIVEQ expr .)
    LEQ             reduce using rule 60 (expr -> lval DIVEQ expr .)
    GEQ             reduce using rule 60 (expr -> lval DIVEQ expr .)
    <               reduce using rule 60 (expr -> lval DIVEQ expr .)
    >               reduce using rule 60 (expr -> lval DIVEQ expr .)
    LAND            reduce using rule 60 (expr -> lval DIVEQ expr .)
    LOR             reduce using rule 60 (expr -> lval DIVEQ expr .)
    ,               reduce using rule 60 (expr -> lval DIVEQ expr .)
    ]               reduce using rule 60 (expr -> lval DIVEQ expr .)
    +               shift and go to state 70
    -               shift and go to state 72
    *               shift and go to state 71
    /               shift and go to state 73
    %               shift and go to state 69
    LSHIFT          shift and go to state 74
    RSHIFT          shift and go to state 75

  ! +               [ reduce using rule 60 (expr -> lval DIVEQ expr .) ]
  ! -               [ reduce using rule 60 (expr -> lval DIVEQ expr .) ]
  ! *               [ reduce using rule 60 (expr -> lval DIVEQ expr .) ]
  ! /               [ reduce using rule 60 (expr -> lval DIVEQ expr .) ]
  ! %               [ reduce using rule 60 (expr -> lval DIVEQ expr .) ]
  ! LSHIFT          [ reduce using rule 60 (expr -> lval DIVEQ expr .) ]
  ! RSHIFT          [ reduce using rule 60 (expr -> lval DIVEQ expr .) ]


state 100

    (72) expr -> ID ( ) .

    +               reduce using rule 72 (expr -> ID ( ) .)
    -               reduce using rule 72 (expr -> ID ( ) .)
    *               reduce using rule 72 (expr -> ID ( ) .)
    /               reduce using rule 72 (expr -> ID ( ) .)
    %               reduce using rule 72 (expr -> ID ( ) .)
    LSHIFT          reduce using rule 72 (expr -> ID ( ) .)
    RSHIFT          reduce using rule 72 (expr -> ID ( ) .)
    ;               reduce using rule 72 (expr -> ID ( ) .)
    )               reduce using rule 72 (expr -> ID ( ) .)
    EQ              reduce using rule 72 (expr -> ID ( ) .)
    NEQ             reduce using rule 72 (expr -> ID ( ) .)
    LEQ             reduce using rule 72 (expr -> ID ( ) .)
    GEQ             reduce using rule 72 (expr -> ID ( ) .)
    <               reduce using rule 72 (expr -> ID ( ) .)
    >               reduce using rule 72 (expr -> ID ( ) .)
    LAND            reduce using rule 72 (expr -> ID ( ) .)
    LOR             reduce using rule 72 (expr -> ID ( ) .)
    ,               reduce using rule 72 (expr -> ID ( ) .)
    ]               reduce using rule 72 (expr -> ID ( ) .)


state 101

    (52) exprs -> expr .
    (62) expr -> expr . + expr
    (63) expr -> expr . - expr
    (64) expr -> expr . * expr
    (65) expr -> expr . / expr
    (66) expr -> expr . % expr
    (67) expr -> expr . LSHIFT expr
    (68) expr -> expr . RSHIFT expr

    )               reduce using rule 52 (exprs -> expr .)
    ,               reduce using rule 52 (exprs -> expr .)
    +               shift and go to state 70
    -               shift and go to state 72
    *               shift and go to state 71
    /               shift and go to state 73
    %               shift and go to state 69
    LSHIFT          shift and go to state 74
    RSHIFT          shift and go to state 75


state 102

    (73) expr -> ID ( exprs . )
    (53) exprs -> exprs . , expr

    )               shift and go to state 129
    ,               shift and go to state 130


state 103

    (77) lval -> ID [ expr . ]
    (62) expr -> expr . + expr
    (63) expr -> expr . - expr
    (64) expr -> expr . * expr
    (65) expr -> expr . / expr
    (66) expr -> expr . % expr
    (67) expr -> expr . LSHIFT expr
    (68) expr -> expr . RSHIFT expr

    ]               shift and go to state 131
    +               shift and go to state 70
    -               shift and go to state 72
    *               shift and go to state 71
    /               shift and go to state 73
    %               shift and go to state 69
    LSHIFT          shift and go to state 74
    RSHIFT          shift and go to state 75


state 104

    (29) stmt -> IF ( cexpr . ) stmt
    (30) stmt -> IF ( cexpr . ) stmt ELSE stmt
    (48) cexpr -> cexpr . LAND cexpr
    (49) cexpr -> cexpr . LOR cexpr

    )               shift and go to state 132
    LAND            shift and go to state 119
    LOR             shift and go to state 121


state 105

    (66) expr -> expr % expr .
    (62) expr -> expr . + expr
    (63) expr -> expr . - expr
    (64) expr -> expr . * expr
    (65) expr -> expr . / expr
    (66) expr -> expr . % expr
    (67) expr -> expr . LSHIFT expr
    (68) expr -> expr . RSHIFT expr

    +               reduce using rule 66 (expr -> expr % expr .)
    -               reduce using rule 66 (expr -> expr % expr .)
    *               reduce using rule 66 (expr -> expr % expr .)
    /               reduce using rule 66 (expr -> expr % expr .)
    %               reduce using rule 66 (expr -> expr % expr .)
    LSHIFT          reduce using rule 66 (expr -> expr % expr .)
    RSHIFT          reduce using rule 66 (expr -> expr % expr .)
    ;               reduce using rule 66 (expr -> expr % expr .)
    )               reduce using rule 66 (expr -> expr % expr .)
    EQ              reduce using rule 66 (expr -> expr % expr .)
    NEQ             reduce using rule 66 (expr -> expr % expr .)
    LEQ             reduce using rule 66 (expr -> expr % expr .)
    GEQ             reduce using rule 66 (expr -> expr % expr .)
    <               reduce using rule 66 (expr -> expr % expr .)
    >               reduce using rule 66 (expr -> expr % expr .)
    LAND            reduce using rule 66 (expr -> expr % expr .)
    LOR             reduce using rule 66 (expr -> expr % expr .)
    ,               reduce using rule 66 (expr -> expr % expr .)
    ]               reduce using rule 66 (expr -> expr % expr .)

  ! +               [ shift and go to state 70 ]
  ! -               [ shift and go to state 72 ]
  ! *               [ shift and go to state 71 ]
  ! /               [ shift and go to state 73 ]
  ! %               [ shift and go to state 69 ]
  ! LSHIFT          [ shift and go to state 74 ]
  ! RSHIFT          [ shift and go to state 75 ]


state 106

    (62) expr -> expr + expr .
    (62) expr -> expr . + expr
    (63) expr -> expr . - expr
    (64) expr -> expr . * expr
    (65) expr -> expr . / expr
    (66) expr -> expr . % expr
    (67) expr -> expr . LSHIFT expr
    (68) expr -> expr . RSHIFT expr

    +               reduce using rule 62 (expr -> expr + expr .)
    -               reduce using rule 62 (expr -> expr + expr .)
    LSHIFT          reduce using rule 62 (expr -> expr + expr .)
    RSHIFT          reduce using rule 62 (expr -> expr + expr .)
    ;               reduce using rule 62 (expr -> expr + expr .)
    )               reduce using rule 62 (expr -> expr + expr .)
    EQ              reduce using rule 62 (expr -> expr + expr .)
    NEQ             reduce using rule 62 (expr -> expr + expr .)
    LEQ             reduce using rule 62 (expr -> expr + expr .)
    GEQ             reduce using rule 62 (expr -> expr + expr .)
    <               reduce using rule 62 (expr -> expr + expr .)
    >               reduce using rule 62 (expr -> expr + expr .)
    LAND            reduce using rule 62 (expr -> expr + expr .)
    LOR             reduce using rule 62 (expr -> expr + expr .)
    ,               reduce using rule 62 (expr -> expr + expr .)
    ]               reduce using rule 62 (expr -> expr + expr .)
    *               shift and go to state 71
    /               shift and go to state 73
    %               shift and go to state 69

  ! *               [ reduce using rule 62 (expr -> expr + expr .) ]
  ! /               [ reduce using rule 62 (expr -> expr + expr .) ]
  ! %               [ reduce using rule 62 (expr -> expr + expr .) ]
  ! +               [ shift and go to state 70 ]
  ! -               [ shift and go to state 72 ]
  ! LSHIFT          [ shift and go to state 74 ]
  ! RSHIFT          [ shift and go to state 75 ]


state 107

    (64) expr -> expr * expr .
    (62) expr -> expr . + expr
    (63) expr -> expr . - expr
    (64) expr -> expr . * expr
    (65) expr -> expr . / expr
    (66) expr -> expr . % expr
    (67) expr -> expr . LSHIFT expr
    (68) expr -> expr . RSHIFT expr

    +               reduce using rule 64 (expr -> expr * expr .)
    -               reduce using rule 64 (expr -> expr * expr .)
    *               reduce using rule 64 (expr -> expr * expr .)
    /               reduce using rule 64 (expr -> expr * expr .)
    %               reduce using rule 64 (expr -> expr * expr .)
    LSHIFT          reduce using rule 64 (expr -> expr * expr .)
    RSHIFT          reduce using rule 64 (expr -> expr * expr .)
    ;               reduce using rule 64 (expr -> expr * expr .)
    )               reduce using rule 64 (expr -> expr * expr .)
    EQ              reduce using rule 64 (expr -> expr * expr .)
    NEQ             reduce using rule 64 (expr -> expr * expr .)
    LEQ             reduce using rule 64 (expr -> expr * expr .)
    GEQ             reduce using rule 64 (expr -> expr * expr .)
    <               reduce using rule 64 (expr -> expr * expr .)
    >               reduce using rule 64 (expr -> expr * expr .)
    LAND            reduce using rule 64 (expr -> expr * expr .)
    LOR             reduce using rule 64 (expr -> expr * expr .)
    ,               reduce using rule 64 (expr -> expr * expr .)
    ]               reduce using rule 64 (expr -> expr * expr .)

  ! +               [ shift and go to state 70 ]
  ! -               [ shift and go to state 72 ]
  ! *               [ shift and go to state 71 ]
  ! /               [ shift and go to state 73 ]
  ! %               [ shift and go to state 69 ]
  ! LSHIFT          [ shift and go to state 74 ]
  ! RSHIFT          [ shift and go to state 75 ]


state 108

    (63) expr -> expr - expr .
    (62) expr -> expr . + expr
    (63) expr -> expr . - expr
    (64) expr -> expr . * expr
    (65) expr -> expr . / expr
    (66) expr -> expr . % expr
    (67) expr -> expr . LSHIFT expr
    (68) expr -> expr . RSHIFT expr

    +               reduce using rule 63 (expr -> expr - expr .)
    -               reduce using rule 63 (expr -> expr - expr .)
    LSHIFT          reduce using rule 63 (expr -> expr - expr .)
    RSHIFT          reduce using rule 63 (expr -> expr - expr .)
    ;               reduce using rule 63 (expr -> expr - expr .)
    )               reduce using rule 63 (expr -> expr - expr .)
    EQ              reduce using rule 63 (expr -> expr - expr .)
    NEQ             reduce using rule 63 (expr -> expr - expr .)
    LEQ             reduce using rule 63 (expr -> expr - expr .)
    GEQ             reduce using rule 63 (expr -> expr - expr .)
    <               reduce using rule 63 (expr -> expr - expr .)
    >               reduce using rule 63 (expr -> expr - expr .)
    LAND            reduce using rule 63 (expr -> expr - expr .)
    LOR             reduce using rule 63 (expr -> expr - expr .)
    ,               reduce using rule 63 (expr -> expr - expr .)
    ]               reduce using rule 63 (expr -> expr - expr .)
    *               shift and go to state 71
    /               shift and go to state 73
    %               shift and go to state 69

  ! *               [ reduce using rule 63 (expr -> expr - expr .) ]
  ! /               [ reduce using rule 63 (expr -> expr - expr .) ]
  ! %               [ reduce using rule 63 (expr -> expr - expr .) ]
  ! +               [ shift and go to state 70 ]
  ! -               [ shift and go to state 72 ]
  ! LSHIFT          [ shift and go to state 74 ]
  ! RSHIFT          [ shift and go to state 75 ]


state 109

    (65) expr -> expr / expr .
    (62) expr -> expr . + expr
    (63) expr -> expr . - expr
    (64) expr -> expr . * expr
    (65) expr -> expr . / expr
    (66) expr -> expr . % expr
    (67) expr -> expr . LSHIFT expr
    (68) expr -> expr . RSHIFT expr

    +               reduce using rule 65 (expr -> expr / expr .)
    -               reduce using rule 65 (expr -> expr / expr .)
    *               reduce using rule 65 (expr -> expr / expr .)
    /               reduce using rule 65 (expr -> expr / expr .)
    %               reduce using rule 65 (expr -> expr / expr .)
    LSHIFT          reduce using rule 65 (expr -> expr / expr .)
    RSHIFT          reduce using rule 65 (expr -> expr / expr .)
    ;               reduce using rule 65 (expr -> expr / expr .)
    )               reduce using rule 65 (expr -> expr / expr .)
    EQ              reduce using rule 65 (expr -> expr / expr .)
    NEQ             reduce using rule 65 (expr -> expr / expr .)
    LEQ             reduce using rule 65 (expr -> expr / expr .)
    GEQ             reduce using rule 65 (expr -> expr / expr .)
    <               reduce using rule 65 (expr -> expr / expr .)
    >               reduce using rule 65 (expr -> expr / expr .)
    LAND            reduce using rule 65 (expr -> expr / expr .)
    LOR             reduce using rule 65 (expr -> expr / expr .)
    ,               reduce using rule 65 (expr -> expr / expr .)
    ]               reduce using rule 65 (expr -> expr / expr .)

  ! +               [ shift and go to state 70 ]
  ! -               [ shift and go to state 72 ]
  ! *               [ shift and go to state 71 ]
  ! /               [ shift and go to state 73 ]
  ! %               [ shift and go to state 69 ]
  ! LSHIFT          [ shift and go to state 74 ]
  ! RSHIFT          [ shift and go to state 75 ]


state 110

    (67) expr -> expr LSHIFT expr .
    (62) expr -> expr . + expr
    (63) expr -> expr . - expr
    (64) expr -> expr . * expr
    (65) expr -> expr . / expr
    (66) expr -> expr . % expr
    (67) expr -> expr . LSHIFT expr
    (68) expr -> expr . RSHIFT expr

    LSHIFT          reduce using rule 67 (expr -> expr LSHIFT expr .)
    RSHIFT          reduce using rule 67 (expr -> expr LSHIFT expr .)
    ;               reduce using rule 67 (expr -> expr LSHIFT expr .)
    )               reduce using rule 67 (expr -> expr LSHIFT expr .)
    EQ              reduce using rule 67 (expr -> expr LSHIFT expr .)
    NEQ             reduce using rule 67 (expr -> expr LSHIFT expr .)
    LEQ             reduce using rule 67 (expr -> expr LSHIFT expr .)
    GEQ             reduce using rule 67 (expr -> expr LSHIFT expr .)
    <               reduce using rule 67 (expr -> expr LSHIFT expr .)
    >               reduce using rule 67 (expr -> expr LSHIFT expr .)
    LAND            reduce using rule 67 (expr -> expr LSHIFT expr .)
    LOR             reduce using rule 67 (expr -> expr LSHIFT expr .)
    ,               reduce using rule 67 (expr -> expr LSHIFT expr .)
    ]               reduce using rule 67 (expr -> expr LSHIFT expr .)
    +               shift and go to state 70
    -               shift and go to state 72
    *               shift and go to state 71
    /               shift and go to state 73
    %               shift and go to state 69

  ! +               [ reduce using rule 67 (expr -> expr LSHIFT expr .) ]
  ! -               [ reduce using rule 67 (expr -> expr LSHIFT expr .) ]
  ! *               [ reduce using rule 67 (expr -> expr LSHIFT expr .) ]
  ! /               [ reduce using rule 67 (expr -> expr LSHIFT expr .) ]
  ! %               [ reduce using rule 67 (expr -> expr LSHIFT expr .) ]
  ! LSHIFT          [ shift and go to state 74 ]
  ! RSHIFT          [ shift and go to state 75 ]


state 111

    (68) expr -> expr RSHIFT expr .
    (62) expr -> expr . + expr
    (63) expr -> expr . - expr
    (64) expr -> expr . * expr
    (65) expr -> expr . / expr
    (66) expr -> expr . % expr
    (67) expr -> expr . LSHIFT expr
    (68) expr -> expr . RSHIFT expr

    LSHIFT          reduce using rule 68 (expr -> expr RSHIFT expr .)
    RSHIFT          reduce using rule 68 (expr -> expr RSHIFT expr .)
    ;               reduce using rule 68 (expr -> expr RSHIFT expr .)
    )               reduce using rule 68 (expr -> expr RSHIFT expr .)
    EQ              reduce using rule 68 (expr -> expr RSHIFT expr .)
    NEQ             reduce using rule 68 (expr -> expr RSHIFT expr .)
    LEQ             reduce using rule 68 (expr -> expr RSHIFT expr .)
    GEQ             reduce using rule 68 (expr -> expr RSHIFT expr .)
    <               reduce using rule 68 (expr -> expr RSHIFT expr .)
    >               reduce using rule 68 (expr -> expr RSHIFT expr .)
    LAND            reduce using rule 68 (expr -> expr RSHIFT expr .)
    LOR             reduce using rule 68 (expr -> expr RSHIFT expr .)
    ,               reduce using rule 68 (expr -> expr RSHIFT expr .)
    ]               reduce using rule 68 (expr -> expr RSHIFT expr .)
    +               shift and go to state 70
    -               shift and go to state 72
    *               shift and go to state 71
    /               shift and go to state 73
    %               shift and go to state 69

  ! +               [ reduce using rule 68 (expr -> expr RSHIFT expr .) ]
  ! -               [ reduce using rule 68 (expr -> expr RSHIFT expr .) ]
  ! *               [ reduce using rule 68 (expr -> expr RSHIFT expr .) ]
  ! /               [ reduce using rule 68 (expr -> expr RSHIFT expr .) ]
  ! %               [ reduce using rule 68 (expr -> expr RSHIFT expr .) ]
  ! LSHIFT          [ shift and go to state 74 ]
  ! RSHIFT          [ shift and go to state 75 ]


state 112

    (25) block -> { stmts } .

    }               reduce using rule 25 (block -> { stmts } .)
    IF              reduce using rule 25 (block -> { stmts } .)
    WHILE           reduce using rule 25 (block -> { stmts } .)
    DO              reduce using rule 25 (block -> { stmts } .)
    FOR             reduce using rule 25 (block -> { stmts } .)
    CONTINUE        reduce using rule 25 (block -> { stmts } .)
    BREAK           reduce using rule 25 (block -> { stmts } .)
    RETURN          reduce using rule 25 (block -> { stmts } .)
    ;               reduce using rule 25 (block -> { stmts } .)
    &               reduce using rule 25 (block -> { stmts } .)
    -               reduce using rule 25 (block -> { stmts } .)
    ID              reduce using rule 25 (block -> { stmts } .)
    (               reduce using rule 25 (block -> { stmts } .)
    {               reduce using rule 25 (block -> { stmts } .)
    SCON            reduce using rule 25 (block -> { stmts } .)
    ICON            reduce using rule 25 (block -> { stmts } .)
    CCON            reduce using rule 25 (block -> { stmts } .)
    FCON            reduce using rule 25 (block -> { stmts } .)
    ELSE            reduce using rule 25 (block -> { stmts } .)


state 113

    (7) dcls -> dcls dcl . ;
    (9) dcl -> dcl . , dclr

    ;               shift and go to state 133
    ,               shift and go to state 16


state 114

    (8) dcl -> type . dclr
    (10) dclr -> . ID
    (11) dclr -> . ID [ ]
    (12) dclr -> . ID [ ICON ]

    ID              shift and go to state 45

    dclr                           shift and go to state 19

state 115

    (24) args -> args , type . dclr
    (10) dclr -> . ID
    (11) dclr -> . ID [ ]
    (12) dclr -> . ID [ ICON ]

    ID              shift and go to state 45

    dclr                           shift and go to state 134

state 116

    (12) dclr -> ID [ ICON ] .

    ;               reduce using rule 12 (dclr -> ID [ ICON ] .)
    ,               reduce using rule 12 (dclr -> ID [ ICON ] .)
    )               reduce using rule 12 (dclr -> ID [ ICON ] .)


state 117

    (32) stmt -> DO stmt WHILE ( . cexpr ) ;
    (42) cexpr -> . expr EQ expr
    (43) cexpr -> . expr NEQ expr
    (44) cexpr -> . expr LEQ expr
    (45) cexpr -> . expr GEQ expr
    (46) cexpr -> . expr < expr
    (47) cexpr -> . expr > expr
    (48) cexpr -> . cexpr LAND cexpr
    (49) cexpr -> . cexpr LOR cexpr
    (50) cexpr -> . ! cexpr
    (51) cexpr -> . expr
    (56) expr -> . lval = expr
    (57) expr -> . lval ADDEQ expr
    (58) expr -> . lval SUBEQ expr
    (59) expr -> . lval MULEQ expr
    (60) expr -> . lval DIVEQ expr
    (61) expr -> . lval MODEQ expr
    (62) expr -> . expr + expr
    (63) expr -> . expr - expr
    (64) expr -> . expr * expr
    (65) expr -> . expr / expr
    (66) expr -> . expr % expr
    (67) expr -> . expr LSHIFT expr
    (68) expr -> . expr RSHIFT expr
    (69) expr -> . & lval
    (70) expr -> . - expr
    (71) expr -> . lval
    (72) expr -> . ID ( )
    (73) expr -> . ID ( exprs )
    (74) expr -> . ( expr )
    (75) expr -> . constant
    (76) lval -> . ID
    (77) lval -> . ID [ expr ]
    (78) constant -> . SCON
    (79) constant -> . ICON
    (80) constant -> . CCON
    (81) constant -> . FCON

    !               shift and go to state 88
    &               shift and go to state 24
    -               shift and go to state 26
    ID              shift and go to state 34
    (               shift and go to state 25
    SCON            shift and go to state 40
    ICON            shift and go to state 30
    CCON            shift and go to state 28
    FCON            shift and go to state 39

    constant                       shift and go to state 27
    expr                           shift and go to state 90
    lval                           shift and go to state 32
    cexpr                          shift and go to state 135

state 118

    (50) cexpr -> ! cexpr .
    (48) cexpr -> cexpr . LAND cexpr
    (49) cexpr -> cexpr . LOR cexpr

    LAND            reduce using rule 50 (cexpr -> ! cexpr .)
    LOR             reduce using rule 50 (cexpr -> ! cexpr .)
    )               reduce using rule 50 (cexpr -> ! cexpr .)
    ;               reduce using rule 50 (cexpr -> ! cexpr .)

  ! LAND            [ shift and go to state 119 ]
  ! LOR             [ shift and go to state 121 ]


state 119

    (48) cexpr -> cexpr LAND . cexpr
    (42) cexpr -> . expr EQ expr
    (43) cexpr -> . expr NEQ expr
    (44) cexpr -> . expr LEQ expr
    (45) cexpr -> . expr GEQ expr
    (46) cexpr -> . expr < expr
    (47) cexpr -> . expr > expr
    (48) cexpr -> . cexpr LAND cexpr
    (49) cexpr -> . cexpr LOR cexpr
    (50) cexpr -> . ! cexpr
    (51) cexpr -> . expr
    (56) expr -> . lval = expr
    (57) expr -> . lval ADDEQ expr
    (58) expr -> . lval SUBEQ expr
    (59) expr -> . lval MULEQ expr
    (60) expr -> . lval DIVEQ expr
    (61) expr -> . lval MODEQ expr
    (62) expr -> . expr + expr
    (63) expr -> . expr - expr
    (64) expr -> . expr * expr
    (65) expr -> . expr / expr
    (66) expr -> . expr % expr
    (67) expr -> . expr LSHIFT expr
    (68) expr -> . expr RSHIFT expr
    (69) expr -> . & lval
    (70) expr -> . - expr
    (71) expr -> . lval
    (72) expr -> . ID ( )
    (73) expr -> . ID ( exprs )
    (74) expr -> . ( expr )
    (75) expr -> . constant
    (76) lval -> . ID
    (77) lval -> . ID [ expr ]
    (78) constant -> . SCON
    (79) constant -> . ICON
    (80) constant -> . CCON
    (81) constant -> . FCON

    !               shift and go to state 88
    &               shift and go to state 24
    -               shift and go to state 26
    ID              shift and go to state 34
    (               shift and go to state 25
    SCON            shift and go to state 40
    ICON            shift and go to state 30
    CCON            shift and go to state 28
    FCON            shift and go to state 39

    expr                           shift and go to state 90
    cexpr                          shift and go to state 136
    constant                       shift and go to state 27
    lval                           shift and go to state 32

state 120

    (31) stmt -> WHILE ( cexpr ) . stmt
    (28) stmt -> . expr ;
    (29) stmt -> . IF ( cexpr ) stmt
    (30) stmt -> . IF ( cexpr ) stmt ELSE stmt
    (31) stmt -> . WHILE ( cexpr ) stmt
    (32) stmt -> . DO stmt WHILE ( cexpr ) ;
    (33) stmt -> . FOR ( expro ; cexpro ; expro ) stmt
    (34) stmt -> . CONTINUE ;
    (35) stmt -> . BREAK ;
    (36) stmt -> . RETURN ;
    (37) stmt -> . RETURN expr ;
    (38) stmt -> . block
    (39) stmt -> . ;
    (56) expr -> . lval = expr
    (57) expr -> . lval ADDEQ expr
    (58) expr -> . lval SUBEQ expr
    (59) expr -> . lval MULEQ expr
    (60) expr -> . lval DIVEQ expr
    (61) expr -> . lval MODEQ expr
    (62) expr -> . expr + expr
    (63) expr -> . expr - expr
    (64) expr -> . expr * expr
    (65) expr -> . expr / expr
    (66) expr -> . expr % expr
    (67) expr -> . expr LSHIFT expr
    (68) expr -> . expr RSHIFT expr
    (69) expr -> . & lval
    (70) expr -> . - expr
    (71) expr -> . lval
    (72) expr -> . ID ( )
    (73) expr -> . ID ( exprs )
    (74) expr -> . ( expr )
    (75) expr -> . constant
    (25) block -> . { stmts }
    (76) lval -> . ID
    (77) lval -> . ID [ expr ]
    (78) constant -> . SCON
    (79) constant -> . ICON
    (80) constant -> . CCON
    (81) constant -> . FCON

    IF              shift and go to state 35
    WHILE           shift and go to state 23
    DO              shift and go to state 21
    FOR             shift and go to state 31
    CONTINUE        shift and go to state 38
    BREAK           shift and go to state 37
    RETURN          shift and go to state 22
    ;               shift and go to state 29
    &               shift and go to state 24
    -               shift and go to state 26
    ID              shift and go to state 34
    (               shift and go to state 25
    {               shift and go to state 41
    SCON            shift and go to state 40
    ICON            shift and go to state 30
    CCON            shift and go to state 28
    FCON            shift and go to state 39

    constant                       shift and go to state 27
    expr                           shift and go to state 36
    stmt                           shift and go to state 137
    lval                           shift and go to state 32
    block                          shift and go to state 43

state 121

    (49) cexpr -> cexpr LOR . cexpr
    (42) cexpr -> . expr EQ expr
    (43) cexpr -> . expr NEQ expr
    (44) cexpr -> . expr LEQ expr
    (45) cexpr -> . expr GEQ expr
    (46) cexpr -> . expr < expr
    (47) cexpr -> . expr > expr
    (48) cexpr -> . cexpr LAND cexpr
    (49) cexpr -> . cexpr LOR cexpr
    (50) cexpr -> . ! cexpr
    (51) cexpr -> . expr
    (56) expr -> . lval = expr
    (57) expr -> . lval ADDEQ expr
    (58) expr -> . lval SUBEQ expr
    (59) expr -> . lval MULEQ expr
    (60) expr -> . lval DIVEQ expr
    (61) expr -> . lval MODEQ expr
    (62) expr -> . expr + expr
    (63) expr -> . expr - expr
    (64) expr -> . expr * expr
    (65) expr -> . expr / expr
    (66) expr -> . expr % expr
    (67) expr -> . expr LSHIFT expr
    (68) expr -> . expr RSHIFT expr
    (69) expr -> . & lval
    (70) expr -> . - expr
    (71) expr -> . lval
    (72) expr -> . ID ( )
    (73) expr -> . ID ( exprs )
    (74) expr -> . ( expr )
    (75) expr -> . constant
    (76) lval -> . ID
    (77) lval -> . ID [ expr ]
    (78) constant -> . SCON
    (79) constant -> . ICON
    (80) constant -> . CCON
    (81) constant -> . FCON

    !               shift and go to state 88
    &               shift and go to state 24
    -               shift and go to state 26
    ID              shift and go to state 34
    (               shift and go to state 25
    SCON            shift and go to state 40
    ICON            shift and go to state 30
    CCON            shift and go to state 28
    FCON            shift and go to state 39

    expr                           shift and go to state 90
    cexpr                          shift and go to state 138
    constant                       shift and go to state 27
    lval                           shift and go to state 32

state 122

    (45) cexpr -> expr GEQ . expr
    (56) expr -> . lval = expr
    (57) expr -> . lval ADDEQ expr
    (58) expr -> . lval SUBEQ expr
    (59) expr -> . lval MULEQ expr
    (60) expr -> . lval DIVEQ expr
    (61) expr -> . lval MODEQ expr
    (62) expr -> . expr + expr
    (63) expr -> . expr - expr
    (64) expr -> . expr * expr
    (65) expr -> . expr / expr
    (66) expr -> . expr % expr
    (67) expr -> . expr LSHIFT expr
    (68) expr -> . expr RSHIFT expr
    (69) expr -> . & lval
    (70) expr -> . - expr
    (71) expr -> . lval
    (72) expr -> . ID ( )
    (73) expr -> . ID ( exprs )
    (74) expr -> . ( expr )
    (75) expr -> . constant
    (76) lval -> . ID
    (77) lval -> . ID [ expr ]
    (78) constant -> . SCON
    (79) constant -> . ICON
    (80) constant -> . CCON
    (81) constant -> . FCON

    &               shift and go to state 24
    -               shift and go to state 26
    ID              shift and go to state 34
    (               shift and go to state 25
    SCON            shift and go to state 40
    ICON            shift and go to state 30
    CCON            shift and go to state 28
    FCON            shift and go to state 39

    expr                           shift and go to state 139
    constant                       shift and go to state 27
    lval                           shift and go to state 32

state 123

    (44) cexpr -> expr LEQ . expr
    (56) expr -> . lval = expr
    (57) expr -> . lval ADDEQ expr
    (58) expr -> . lval SUBEQ expr
    (59) expr -> . lval MULEQ expr
    (60) expr -> . lval DIVEQ expr
    (61) expr -> . lval MODEQ expr
    (62) expr -> . expr + expr
    (63) expr -> . expr - expr
    (64) expr -> . expr * expr
    (65) expr -> . expr / expr
    (66) expr -> . expr % expr
    (67) expr -> . expr LSHIFT expr
    (68) expr -> . expr RSHIFT expr
    (69) expr -> . & lval
    (70) expr -> . - expr
    (71) expr -> . lval
    (72) expr -> . ID ( )
    (73) expr -> . ID ( exprs )
    (74) expr -> . ( expr )
    (75) expr -> . constant
    (76) lval -> . ID
    (77) lval -> . ID [ expr ]
    (78) constant -> . SCON
    (79) constant -> . ICON
    (80) constant -> . CCON
    (81) constant -> . FCON

    &               shift and go to state 24
    -               shift and go to state 26
    ID              shift and go to state 34
    (               shift and go to state 25
    SCON            shift and go to state 40
    ICON            shift and go to state 30
    CCON            shift and go to state 28
    FCON            shift and go to state 39

    expr                           shift and go to state 140
    constant                       shift and go to state 27
    lval                           shift and go to state 32

state 124

    (47) cexpr -> expr > . expr
    (56) expr -> . lval = expr
    (57) expr -> . lval ADDEQ expr
    (58) expr -> . lval SUBEQ expr
    (59) expr -> . lval MULEQ expr
    (60) expr -> . lval DIVEQ expr
    (61) expr -> . lval MODEQ expr
    (62) expr -> . expr + expr
    (63) expr -> . expr - expr
    (64) expr -> . expr * expr
    (65) expr -> . expr / expr
    (66) expr -> . expr % expr
    (67) expr -> . expr LSHIFT expr
    (68) expr -> . expr RSHIFT expr
    (69) expr -> . & lval
    (70) expr -> . - expr
    (71) expr -> . lval
    (72) expr -> . ID ( )
    (73) expr -> . ID ( exprs )
    (74) expr -> . ( expr )
    (75) expr -> . constant
    (76) lval -> . ID
    (77) lval -> . ID [ expr ]
    (78) constant -> . SCON
    (79) constant -> . ICON
    (80) constant -> . CCON
    (81) constant -> . FCON

    &               shift and go to state 24
    -               shift and go to state 26
    ID              shift and go to state 34
    (               shift and go to state 25
    SCON            shift and go to state 40
    ICON            shift and go to state 30
    CCON            shift and go to state 28
    FCON            shift and go to state 39

    expr                           shift and go to state 141
    constant                       shift and go to state 27
    lval                           shift and go to state 32

state 125

    (42) cexpr -> expr EQ . expr
    (56) expr -> . lval = expr
    (57) expr -> . lval ADDEQ expr
    (58) expr -> . lval SUBEQ expr
    (59) expr -> . lval MULEQ expr
    (60) expr -> . lval DIVEQ expr
    (61) expr -> . lval MODEQ expr
    (62) expr -> . expr + expr
    (63) expr -> . expr - expr
    (64) expr -> . expr * expr
    (65) expr -> . expr / expr
    (66) expr -> . expr % expr
    (67) expr -> . expr LSHIFT expr
    (68) expr -> . expr RSHIFT expr
    (69) expr -> . & lval
    (70) expr -> . - expr
    (71) expr -> . lval
    (72) expr -> . ID ( )
    (73) expr -> . ID ( exprs )
    (74) expr -> . ( expr )
    (75) expr -> . constant
    (76) lval -> . ID
    (77) lval -> . ID [ expr ]
    (78) constant -> . SCON
    (79) constant -> . ICON
    (80) constant -> . CCON
    (81) constant -> . FCON

    &               shift and go to state 24
    -               shift and go to state 26
    ID              shift and go to state 34
    (               shift and go to state 25
    SCON            shift and go to state 40
    ICON            shift and go to state 30
    CCON            shift and go to state 28
    FCON            shift and go to state 39

    expr                           shift and go to state 142
    constant                       shift and go to state 27
    lval                           shift and go to state 32

state 126

    (46) cexpr -> expr < . expr
    (56) expr -> . lval = expr
    (57) expr -> . lval ADDEQ expr
    (58) expr -> . lval SUBEQ expr
    (59) expr -> . lval MULEQ expr
    (60) expr -> . lval DIVEQ expr
    (61) expr -> . lval MODEQ expr
    (62) expr -> . expr + expr
    (63) expr -> . expr - expr
    (64) expr -> . expr * expr
    (65) expr -> . expr / expr
    (66) expr -> . expr % expr
    (67) expr -> . expr LSHIFT expr
    (68) expr -> . expr RSHIFT expr
    (69) expr -> . & lval
    (70) expr -> . - expr
    (71) expr -> . lval
    (72) expr -> . ID ( )
    (73) expr -> . ID ( exprs )
    (74) expr -> . ( expr )
    (75) expr -> . constant
    (76) lval -> . ID
    (77) lval -> . ID [ expr ]
    (78) constant -> . SCON
    (79) constant -> . ICON
    (80) constant -> . CCON
    (81) constant -> . FCON

    &               shift and go to state 24
    -               shift and go to state 26
    ID              shift and go to state 34
    (               shift and go to state 25
    SCON            shift and go to state 40
    ICON            shift and go to state 30
    CCON            shift and go to state 28
    FCON            shift and go to state 39

    expr                           shift and go to state 143
    constant                       shift and go to state 27
    lval                           shift and go to state 32

state 127

    (43) cexpr -> expr NEQ . expr
    (56) expr -> . lval = expr
    (57) expr -> . lval ADDEQ expr
    (58) expr -> . lval SUBEQ expr
    (59) expr -> . lval MULEQ expr
    (60) expr -> . lval DIVEQ expr
    (61) expr -> . lval MODEQ expr
    (62) expr -> . expr + expr
    (63) expr -> . expr - expr
    (64) expr -> . expr * expr
    (65) expr -> . expr / expr
    (66) expr -> . expr % expr
    (67) expr -> . expr LSHIFT expr
    (68) expr -> . expr RSHIFT expr
    (69) expr -> . & lval
    (70) expr -> . - expr
    (71) expr -> . lval
    (72) expr -> . ID ( )
    (73) expr -> . ID ( exprs )
    (74) expr -> . ( expr )
    (75) expr -> . constant
    (76) lval -> . ID
    (77) lval -> . ID [ expr ]
    (78) constant -> . SCON
    (79) constant -> . ICON
    (80) constant -> . CCON
    (81) constant -> . FCON

    &               shift and go to state 24
    -               shift and go to state 26
    ID              shift and go to state 34
    (               shift and go to state 25
    SCON            shift and go to state 40
    ICON            shift and go to state 30
    CCON            shift and go to state 28
    FCON            shift and go to state 39

    expr                           shift and go to state 144
    constant                       shift and go to state 27
    lval                           shift and go to state 32

state 128

    (33) stmt -> FOR ( expro ; . cexpro ; expro ) stmt
    (40) cexpro -> .
    (41) cexpro -> . cexpr
    (42) cexpr -> . expr EQ expr
    (43) cexpr -> . expr NEQ expr
    (44) cexpr -> . expr LEQ expr
    (45) cexpr -> . expr GEQ expr
    (46) cexpr -> . expr < expr
    (47) cexpr -> . expr > expr
    (48) cexpr -> . cexpr LAND cexpr
    (49) cexpr -> . cexpr LOR cexpr
    (50) cexpr -> . ! cexpr
    (51) cexpr -> . expr
    (56) expr -> . lval = expr
    (57) expr -> . lval ADDEQ expr
    (58) expr -> . lval SUBEQ expr
    (59) expr -> . lval MULEQ expr
    (60) expr -> . lval DIVEQ expr
    (61) expr -> . lval MODEQ expr
    (62) expr -> . expr + expr
    (63) expr -> . expr - expr
    (64) expr -> . expr * expr
    (65) expr -> . expr / expr
    (66) expr -> . expr % expr
    (67) expr -> . expr LSHIFT expr
    (68) expr -> . expr RSHIFT expr
    (69) expr -> . & lval
    (70) expr -> . - expr
    (71) expr -> . lval
    (72) expr -> . ID ( )
    (73) expr -> . ID ( exprs )
    (74) expr -> . ( expr )
    (75) expr -> . constant
    (76) lval -> . ID
    (77) lval -> . ID [ expr ]
    (78) constant -> . SCON
    (79) constant -> . ICON
    (80) constant -> . CCON
    (81) constant -> . FCON

    ;               reduce using rule 40 (cexpro -> .)
    !               shift and go to state 88
    &               shift and go to state 24
    -               shift and go to state 26
    ID              shift and go to state 34
    (               shift and go to state 25
    SCON            shift and go to state 40
    ICON            shift and go to state 30
    CCON            shift and go to state 28
    FCON            shift and go to state 39

    constant                       shift and go to state 27
    expr                           shift and go to state 90
    lval                           shift and go to state 32
    cexpro                         shift and go to state 146
    cexpr                          shift and go to state 145

state 129

    (73) expr -> ID ( exprs ) .

    +               reduce using rule 73 (expr -> ID ( exprs ) .)
    -               reduce using rule 73 (expr -> ID ( exprs ) .)
    *               reduce using rule 73 (expr -> ID ( exprs ) .)
    /               reduce using rule 73 (expr -> ID ( exprs ) .)
    %               reduce using rule 73 (expr -> ID ( exprs ) .)
    LSHIFT          reduce using rule 73 (expr -> ID ( exprs ) .)
    RSHIFT          reduce using rule 73 (expr -> ID ( exprs ) .)
    ;               reduce using rule 73 (expr -> ID ( exprs ) .)
    )               reduce using rule 73 (expr -> ID ( exprs ) .)
    EQ              reduce using rule 73 (expr -> ID ( exprs ) .)
    NEQ             reduce using rule 73 (expr -> ID ( exprs ) .)
    LEQ             reduce using rule 73 (expr -> ID ( exprs ) .)
    GEQ             reduce using rule 73 (expr -> ID ( exprs ) .)
    <               reduce using rule 73 (expr -> ID ( exprs ) .)
    >               reduce using rule 73 (expr -> ID ( exprs ) .)
    LAND            reduce using rule 73 (expr -> ID ( exprs ) .)
    LOR             reduce using rule 73 (expr -> ID ( exprs ) .)
    ,               reduce using rule 73 (expr -> ID ( exprs ) .)
    ]               reduce using rule 73 (expr -> ID ( exprs ) .)


state 130

    (53) exprs -> exprs , . expr
    (56) expr -> . lval = expr
    (57) expr -> . lval ADDEQ expr
    (58) expr -> . lval SUBEQ expr
    (59) expr -> . lval MULEQ expr
    (60) expr -> . lval DIVEQ expr
    (61) expr -> . lval MODEQ expr
    (62) expr -> . expr + expr
    (63) expr -> . expr - expr
    (64) expr -> . expr * expr
    (65) expr -> . expr / expr
    (66) expr -> . expr % expr
    (67) expr -> . expr LSHIFT expr
    (68) expr -> . expr RSHIFT expr
    (69) expr -> . & lval
    (70) expr -> . - expr
    (71) expr -> . lval
    (72) expr -> . ID ( )
    (73) expr -> . ID ( exprs )
    (74) expr -> . ( expr )
    (75) expr -> . constant
    (76) lval -> . ID
    (77) lval -> . ID [ expr ]
    (78) constant -> . SCON
    (79) constant -> . ICON
    (80) constant -> . CCON
    (81) constant -> . FCON

    &               shift and go to state 24
    -               shift and go to state 26
    ID              shift and go to state 34
    (               shift and go to state 25
    SCON            shift and go to state 40
    ICON            shift and go to state 30
    CCON            shift and go to state 28
    FCON            shift and go to state 39

    constant                       shift and go to state 27
    lval                           shift and go to state 32
    expr                           shift and go to state 147

state 131

    (77) lval -> ID [ expr ] .

    =               reduce using rule 77 (lval -> ID [ expr ] .)
    ADDEQ           reduce using rule 77 (lval -> ID [ expr ] .)
    SUBEQ           reduce using rule 77 (lval -> ID [ expr ] .)
    MULEQ           reduce using rule 77 (lval -> ID [ expr ] .)
    DIVEQ           reduce using rule 77 (lval -> ID [ expr ] .)
    MODEQ           reduce using rule 77 (lval -> ID [ expr ] .)
    +               reduce using rule 77 (lval -> ID [ expr ] .)
    -               reduce using rule 77 (lval -> ID [ expr ] .)
    *               reduce using rule 77 (lval -> ID [ expr ] .)
    /               reduce using rule 77 (lval -> ID [ expr ] .)
    %               reduce using rule 77 (lval -> ID [ expr ] .)
    LSHIFT          reduce using rule 77 (lval -> ID [ expr ] .)
    RSHIFT          reduce using rule 77 (lval -> ID [ expr ] .)
    ;               reduce using rule 77 (lval -> ID [ expr ] .)
    )               reduce using rule 77 (lval -> ID [ expr ] .)
    EQ              reduce using rule 77 (lval -> ID [ expr ] .)
    NEQ             reduce using rule 77 (lval -> ID [ expr ] .)
    LEQ             reduce using rule 77 (lval -> ID [ expr ] .)
    GEQ             reduce using rule 77 (lval -> ID [ expr ] .)
    <               reduce using rule 77 (lval -> ID [ expr ] .)
    >               reduce using rule 77 (lval -> ID [ expr ] .)
    LAND            reduce using rule 77 (lval -> ID [ expr ] .)
    LOR             reduce using rule 77 (lval -> ID [ expr ] .)
    ,               reduce using rule 77 (lval -> ID [ expr ] .)
    ]               reduce using rule 77 (lval -> ID [ expr ] .)


state 132

    (29) stmt -> IF ( cexpr ) . stmt
    (30) stmt -> IF ( cexpr ) . stmt ELSE stmt
    (28) stmt -> . expr ;
    (29) stmt -> . IF ( cexpr ) stmt
    (30) stmt -> . IF ( cexpr ) stmt ELSE stmt
    (31) stmt -> . WHILE ( cexpr ) stmt
    (32) stmt -> . DO stmt WHILE ( cexpr ) ;
    (33) stmt -> . FOR ( expro ; cexpro ; expro ) stmt
    (34) stmt -> . CONTINUE ;
    (35) stmt -> . BREAK ;
    (36) stmt -> . RETURN ;
    (37) stmt -> . RETURN expr ;
    (38) stmt -> . block
    (39) stmt -> . ;
    (56) expr -> . lval = expr
    (57) expr -> . lval ADDEQ expr
    (58) expr -> . lval SUBEQ expr
    (59) expr -> . lval MULEQ expr
    (60) expr -> . lval DIVEQ expr
    (61) expr -> . lval MODEQ expr
    (62) expr -> . expr + expr
    (63) expr -> . expr - expr
    (64) expr -> . expr * expr
    (65) expr -> . expr / expr
    (66) expr -> . expr % expr
    (67) expr -> . expr LSHIFT expr
    (68) expr -> . expr RSHIFT expr
    (69) expr -> . & lval
    (70) expr -> . - expr
    (71) expr -> . lval
    (72) expr -> . ID ( )
    (73) expr -> . ID ( exprs )
    (74) expr -> . ( expr )
    (75) expr -> . constant
    (25) block -> . { stmts }
    (76) lval -> . ID
    (77) lval -> . ID [ expr ]
    (78) constant -> . SCON
    (79) constant -> . ICON
    (80) constant -> . CCON
    (81) constant -> . FCON

    IF              shift and go to state 35
    WHILE           shift and go to state 23
    DO              shift and go to state 21
    FOR             shift and go to state 31
    CONTINUE        shift and go to state 38
    BREAK           shift and go to state 37
    RETURN          shift and go to state 22
    ;               shift and go to state 29
    &               shift and go to state 24
    -               shift and go to state 26
    ID              shift and go to state 34
    (               shift and go to state 25
    {               shift and go to state 41
    SCON            shift and go to state 40
    ICON            shift and go to state 30
    CCON            shift and go to state 28
    FCON            shift and go to state 39

    constant                       shift and go to state 27
    expr                           shift and go to state 36
    stmt                           shift and go to state 148
    lval                           shift and go to state 32
    block                          shift and go to state 43

state 133

    (7) dcls -> dcls dcl ; .

    CHAR            reduce using rule 7 (dcls -> dcls dcl ; .)
    FLOAT           reduce using rule 7 (dcls -> dcls dcl ; .)
    DOUBLE          reduce using rule 7 (dcls -> dcls dcl ; .)
    INT             reduce using rule 7 (dcls -> dcls dcl ; .)
    }               reduce using rule 7 (dcls -> dcls dcl ; .)
    IF              reduce using rule 7 (dcls -> dcls dcl ; .)
    WHILE           reduce using rule 7 (dcls -> dcls dcl ; .)
    DO              reduce using rule 7 (dcls -> dcls dcl ; .)
    FOR             reduce using rule 7 (dcls -> dcls dcl ; .)
    CONTINUE        reduce using rule 7 (dcls -> dcls dcl ; .)
    BREAK           reduce using rule 7 (dcls -> dcls dcl ; .)
    RETURN          reduce using rule 7 (dcls -> dcls dcl ; .)
    ;               reduce using rule 7 (dcls -> dcls dcl ; .)
    &               reduce using rule 7 (dcls -> dcls dcl ; .)
    -               reduce using rule 7 (dcls -> dcls dcl ; .)
    ID              reduce using rule 7 (dcls -> dcls dcl ; .)
    (               reduce using rule 7 (dcls -> dcls dcl ; .)
    {               reduce using rule 7 (dcls -> dcls dcl ; .)
    SCON            reduce using rule 7 (dcls -> dcls dcl ; .)
    ICON            reduce using rule 7 (dcls -> dcls dcl ; .)
    CCON            reduce using rule 7 (dcls -> dcls dcl ; .)
    FCON            reduce using rule 7 (dcls -> dcls dcl ; .)


state 134

    (24) args -> args , type dclr .

    )               reduce using rule 24 (args -> args , type dclr .)
    ,               reduce using rule 24 (args -> args , type dclr .)


state 135

    (32) stmt -> DO stmt WHILE ( cexpr . ) ;
    (48) cexpr -> cexpr . LAND cexpr
    (49) cexpr -> cexpr . LOR cexpr

    )               shift and go to state 149
    LAND            shift and go to state 119
    LOR             shift and go to state 121


state 136

    (48) cexpr -> cexpr LAND cexpr .
    (48) cexpr -> cexpr . LAND cexpr
    (49) cexpr -> cexpr . LOR cexpr

    LAND            reduce using rule 48 (cexpr -> cexpr LAND cexpr .)
    LOR             reduce using rule 48 (cexpr -> cexpr LAND cexpr .)
    )               reduce using rule 48 (cexpr -> cexpr LAND cexpr .)
    ;               reduce using rule 48 (cexpr -> cexpr LAND cexpr .)

  ! LAND            [ shift and go to state 119 ]
  ! LOR             [ shift and go to state 121 ]


state 137

    (31) stmt -> WHILE ( cexpr ) stmt .

    }               reduce using rule 31 (stmt -> WHILE ( cexpr ) stmt .)
    IF              reduce using rule 31 (stmt -> WHILE ( cexpr ) stmt .)
    WHILE           reduce using rule 31 (stmt -> WHILE ( cexpr ) stmt .)
    DO              reduce using rule 31 (stmt -> WHILE ( cexpr ) stmt .)
    FOR             reduce using rule 31 (stmt -> WHILE ( cexpr ) stmt .)
    CONTINUE        reduce using rule 31 (stmt -> WHILE ( cexpr ) stmt .)
    BREAK           reduce using rule 31 (stmt -> WHILE ( cexpr ) stmt .)
    RETURN          reduce using rule 31 (stmt -> WHILE ( cexpr ) stmt .)
    ;               reduce using rule 31 (stmt -> WHILE ( cexpr ) stmt .)
    &               reduce using rule 31 (stmt -> WHILE ( cexpr ) stmt .)
    -               reduce using rule 31 (stmt -> WHILE ( cexpr ) stmt .)
    ID              reduce using rule 31 (stmt -> WHILE ( cexpr ) stmt .)
    (               reduce using rule 31 (stmt -> WHILE ( cexpr ) stmt .)
    {               reduce using rule 31 (stmt -> WHILE ( cexpr ) stmt .)
    SCON            reduce using rule 31 (stmt -> WHILE ( cexpr ) stmt .)
    ICON            reduce using rule 31 (stmt -> WHILE ( cexpr ) stmt .)
    CCON            reduce using rule 31 (stmt -> WHILE ( cexpr ) stmt .)
    FCON            reduce using rule 31 (stmt -> WHILE ( cexpr ) stmt .)
    ELSE            reduce using rule 31 (stmt -> WHILE ( cexpr ) stmt .)


state 138

    (49) cexpr -> cexpr LOR cexpr .
    (48) cexpr -> cexpr . LAND cexpr
    (49) cexpr -> cexpr . LOR cexpr

    LOR             reduce using rule 49 (cexpr -> cexpr LOR cexpr .)
    )               reduce using rule 49 (cexpr -> cexpr LOR cexpr .)
    ;               reduce using rule 49 (cexpr -> cexpr LOR cexpr .)
    LAND            shift and go to state 119

  ! LAND            [ reduce using rule 49 (cexpr -> cexpr LOR cexpr .) ]
  ! LOR             [ shift and go to state 121 ]


state 139

    (45) cexpr -> expr GEQ expr .
    (62) expr -> expr . + expr
    (63) expr -> expr . - expr
    (64) expr -> expr . * expr
    (65) expr -> expr . / expr
    (66) expr -> expr . % expr
    (67) expr -> expr . LSHIFT expr
    (68) expr -> expr . RSHIFT expr

    LAND            reduce using rule 45 (cexpr -> expr GEQ expr .)
    LOR             reduce using rule 45 (cexpr -> expr GEQ expr .)
    )               reduce using rule 45 (cexpr -> expr GEQ expr .)
    ;               reduce using rule 45 (cexpr -> expr GEQ expr .)
    +               shift and go to state 70
    -               shift and go to state 72
    *               shift and go to state 71
    /               shift and go to state 73
    %               shift and go to state 69
    LSHIFT          shift and go to state 74
    RSHIFT          shift and go to state 75


state 140

    (44) cexpr -> expr LEQ expr .
    (62) expr -> expr . + expr
    (63) expr -> expr . - expr
    (64) expr -> expr . * expr
    (65) expr -> expr . / expr
    (66) expr -> expr . % expr
    (67) expr -> expr . LSHIFT expr
    (68) expr -> expr . RSHIFT expr

    LAND            reduce using rule 44 (cexpr -> expr LEQ expr .)
    LOR             reduce using rule 44 (cexpr -> expr LEQ expr .)
    )               reduce using rule 44 (cexpr -> expr LEQ expr .)
    ;               reduce using rule 44 (cexpr -> expr LEQ expr .)
    +               shift and go to state 70
    -               shift and go to state 72
    *               shift and go to state 71
    /               shift and go to state 73
    %               shift and go to state 69
    LSHIFT          shift and go to state 74
    RSHIFT          shift and go to state 75


state 141

    (47) cexpr -> expr > expr .
    (62) expr -> expr . + expr
    (63) expr -> expr . - expr
    (64) expr -> expr . * expr
    (65) expr -> expr . / expr
    (66) expr -> expr . % expr
    (67) expr -> expr . LSHIFT expr
    (68) expr -> expr . RSHIFT expr

    LAND            reduce using rule 47 (cexpr -> expr > expr .)
    LOR             reduce using rule 47 (cexpr -> expr > expr .)
    )               reduce using rule 47 (cexpr -> expr > expr .)
    ;               reduce using rule 47 (cexpr -> expr > expr .)
    +               shift and go to state 70
    -               shift and go to state 72
    *               shift and go to state 71
    /               shift and go to state 73
    %               shift and go to state 69
    LSHIFT          shift and go to state 74
    RSHIFT          shift and go to state 75


state 142

    (42) cexpr -> expr EQ expr .
    (62) expr -> expr . + expr
    (63) expr -> expr . - expr
    (64) expr -> expr . * expr
    (65) expr -> expr . / expr
    (66) expr -> expr . % expr
    (67) expr -> expr . LSHIFT expr
    (68) expr -> expr . RSHIFT expr

    LAND            reduce using rule 42 (cexpr -> expr EQ expr .)
    LOR             reduce using rule 42 (cexpr -> expr EQ expr .)
    )               reduce using rule 42 (cexpr -> expr EQ expr .)
    ;               reduce using rule 42 (cexpr -> expr EQ expr .)
    +               shift and go to state 70
    -               shift and go to state 72
    *               shift and go to state 71
    /               shift and go to state 73
    %               shift and go to state 69
    LSHIFT          shift and go to state 74
    RSHIFT          shift and go to state 75


state 143

    (46) cexpr -> expr < expr .
    (62) expr -> expr . + expr
    (63) expr -> expr . - expr
    (64) expr -> expr . * expr
    (65) expr -> expr . / expr
    (66) expr -> expr . % expr
    (67) expr -> expr . LSHIFT expr
    (68) expr -> expr . RSHIFT expr

    LAND            reduce using rule 46 (cexpr -> expr < expr .)
    LOR             reduce using rule 46 (cexpr -> expr < expr .)
    )               reduce using rule 46 (cexpr -> expr < expr .)
    ;               reduce using rule 46 (cexpr -> expr < expr .)
    +               shift and go to state 70
    -               shift and go to state 72
    *               shift and go to state 71
    /               shift and go to state 73
    %               shift and go to state 69
    LSHIFT          shift and go to state 74
    RSHIFT          shift and go to state 75


state 144

    (43) cexpr -> expr NEQ expr .
    (62) expr -> expr . + expr
    (63) expr -> expr . - expr
    (64) expr -> expr . * expr
    (65) expr -> expr . / expr
    (66) expr -> expr . % expr
    (67) expr -> expr . LSHIFT expr
    (68) expr -> expr . RSHIFT expr

    LAND            reduce using rule 43 (cexpr -> expr NEQ expr .)
    LOR             reduce using rule 43 (cexpr -> expr NEQ expr .)
    )               reduce using rule 43 (cexpr -> expr NEQ expr .)
    ;               reduce using rule 43 (cexpr -> expr NEQ expr .)
    +               shift and go to state 70
    -               shift and go to state 72
    *               shift and go to state 71
    /               shift and go to state 73
    %               shift and go to state 69
    LSHIFT          shift and go to state 74
    RSHIFT          shift and go to state 75


state 145

    (41) cexpro -> cexpr .
    (48) cexpr -> cexpr . LAND cexpr
    (49) cexpr -> cexpr . LOR cexpr

    ;               reduce using rule 41 (cexpro -> cexpr .)
    LAND            shift and go to state 119
    LOR             shift and go to state 121


state 146

    (33) stmt -> FOR ( expro ; cexpro . ; expro ) stmt

    ;               shift and go to state 150


state 147

    (53) exprs -> exprs , expr .
    (62) expr -> expr . + expr
    (63) expr -> expr . - expr
    (64) expr -> expr . * expr
    (65) expr -> expr . / expr
    (66) expr -> expr . % expr
    (67) expr -> expr . LSHIFT expr
    (68) expr -> expr . RSHIFT expr

    )               reduce using rule 53 (exprs -> exprs , expr .)
    ,               reduce using rule 53 (exprs -> exprs , expr .)
    +               shift and go to state 70
    -               shift and go to state 72
    *               shift and go to state 71
    /               shift and go to state 73
    %               shift and go to state 69
    LSHIFT          shift and go to state 74
    RSHIFT          shift and go to state 75


state 148

    (29) stmt -> IF ( cexpr ) stmt .
    (30) stmt -> IF ( cexpr ) stmt . ELSE stmt

  ! shift/reduce conflict for ELSE resolved as shift
    }               reduce using rule 29 (stmt -> IF ( cexpr ) stmt .)
    IF              reduce using rule 29 (stmt -> IF ( cexpr ) stmt .)
    WHILE           reduce using rule 29 (stmt -> IF ( cexpr ) stmt .)
    DO              reduce using rule 29 (stmt -> IF ( cexpr ) stmt .)
    FOR             reduce using rule 29 (stmt -> IF ( cexpr ) stmt .)
    CONTINUE        reduce using rule 29 (stmt -> IF ( cexpr ) stmt .)
    BREAK           reduce using rule 29 (stmt -> IF ( cexpr ) stmt .)
    RETURN          reduce using rule 29 (stmt -> IF ( cexpr ) stmt .)
    ;               reduce using rule 29 (stmt -> IF ( cexpr ) stmt .)
    &               reduce using rule 29 (stmt -> IF ( cexpr ) stmt .)
    -               reduce using rule 29 (stmt -> IF ( cexpr ) stmt .)
    ID              reduce using rule 29 (stmt -> IF ( cexpr ) stmt .)
    (               reduce using rule 29 (stmt -> IF ( cexpr ) stmt .)
    {               reduce using rule 29 (stmt -> IF ( cexpr ) stmt .)
    SCON            reduce using rule 29 (stmt -> IF ( cexpr ) stmt .)
    ICON            reduce using rule 29 (stmt -> IF ( cexpr ) stmt .)
    CCON            reduce using rule 29 (stmt -> IF ( cexpr ) stmt .)
    FCON            reduce using rule 29 (stmt -> IF ( cexpr ) stmt .)
    ELSE            shift and go to state 151

  ! ELSE            [ reduce using rule 29 (stmt -> IF ( cexpr ) stmt .) ]


state 149

    (32) stmt -> DO stmt WHILE ( cexpr ) . ;

    ;               shift and go to state 152


state 150

    (33) stmt -> FOR ( expro ; cexpro ; . expro ) stmt
    (54) expro -> .
    (55) expro -> . expr
    (56) expr -> . lval = expr
    (57) expr -> . lval ADDEQ expr
    (58) expr -> . lval SUBEQ expr
    (59) expr -> . lval MULEQ expr
    (60) expr -> . lval DIVEQ expr
    (61) expr -> . lval MODEQ expr
    (62) expr -> . expr + expr
    (63) expr -> . expr - expr
    (64) expr -> . expr * expr
    (65) expr -> . expr / expr
    (66) expr -> . expr % expr
    (67) expr -> . expr LSHIFT expr
    (68) expr -> . expr RSHIFT expr
    (69) expr -> . & lval
    (70) expr -> . - expr
    (71) expr -> . lval
    (72) expr -> . ID ( )
    (73) expr -> . ID ( exprs )
    (74) expr -> . ( expr )
    (75) expr -> . constant
    (76) lval -> . ID
    (77) lval -> . ID [ expr ]
    (78) constant -> . SCON
    (79) constant -> . ICON
    (80) constant -> . CCON
    (81) constant -> . FCON

    )               reduce using rule 54 (expro -> .)
    &               shift and go to state 24
    -               shift and go to state 26
    ID              shift and go to state 34
    (               shift and go to state 25
    SCON            shift and go to state 40
    ICON            shift and go to state 30
    CCON            shift and go to state 28
    FCON            shift and go to state 39

    constant                       shift and go to state 27
    expr                           shift and go to state 92
    expro                          shift and go to state 153
    lval                           shift and go to state 32

state 151

    (30) stmt -> IF ( cexpr ) stmt ELSE . stmt
    (28) stmt -> . expr ;
    (29) stmt -> . IF ( cexpr ) stmt
    (30) stmt -> . IF ( cexpr ) stmt ELSE stmt
    (31) stmt -> . WHILE ( cexpr ) stmt
    (32) stmt -> . DO stmt WHILE ( cexpr ) ;
    (33) stmt -> . FOR ( expro ; cexpro ; expro ) stmt
    (34) stmt -> . CONTINUE ;
    (35) stmt -> . BREAK ;
    (36) stmt -> . RETURN ;
    (37) stmt -> . RETURN expr ;
    (38) stmt -> . block
    (39) stmt -> . ;
    (56) expr -> . lval = expr
    (57) expr -> . lval ADDEQ expr
    (58) expr -> . lval SUBEQ expr
    (59) expr -> . lval MULEQ expr
    (60) expr -> . lval DIVEQ expr
    (61) expr -> . lval MODEQ expr
    (62) expr -> . expr + expr
    (63) expr -> . expr - expr
    (64) expr -> . expr * expr
    (65) expr -> . expr / expr
    (66) expr -> . expr % expr
    (67) expr -> . expr LSHIFT expr
    (68) expr -> . expr RSHIFT expr
    (69) expr -> . & lval
    (70) expr -> . - expr
    (71) expr -> . lval
    (72) expr -> . ID ( )
    (73) expr -> . ID ( exprs )
    (74) expr -> . ( expr )
    (75) expr -> . constant
    (25) block -> . { stmts }
    (76) lval -> . ID
    (77) lval -> . ID [ expr ]
    (78) constant -> . SCON
    (79) constant -> . ICON
    (80) constant -> . CCON
    (81) constant -> . FCON

    IF              shift and go to state 35
    WHILE           shift and go to state 23
    DO              shift and go to state 21
    FOR             shift and go to state 31
    CONTINUE        shift and go to state 38
    BREAK           shift and go to state 37
    RETURN          shift and go to state 22
    ;               shift and go to state 29
    &               shift and go to state 24
    -               shift and go to state 26
    ID              shift and go to state 34
    (               shift and go to state 25
    {               shift and go to state 41
    SCON            shift and go to state 40
    ICON            shift and go to state 30
    CCON            shift and go to state 28
    FCON            shift and go to state 39

    constant                       shift and go to state 27
    expr                           shift and go to state 36
    stmt                           shift and go to state 154
    lval                           shift and go to state 32
    block                          shift and go to state 43

state 152

    (32) stmt -> DO stmt WHILE ( cexpr ) ; .

    }               reduce using rule 32 (stmt -> DO stmt WHILE ( cexpr ) ; .)
    IF              reduce using rule 32 (stmt -> DO stmt WHILE ( cexpr ) ; .)
    WHILE           reduce using rule 32 (stmt -> DO stmt WHILE ( cexpr ) ; .)
    DO              reduce using rule 32 (stmt -> DO stmt WHILE ( cexpr ) ; .)
    FOR             reduce using rule 32 (stmt -> DO stmt WHILE ( cexpr ) ; .)
    CONTINUE        reduce using rule 32 (stmt -> DO stmt WHILE ( cexpr ) ; .)
    BREAK           reduce using rule 32 (stmt -> DO stmt WHILE ( cexpr ) ; .)
    RETURN          reduce using rule 32 (stmt -> DO stmt WHILE ( cexpr ) ; .)
    ;               reduce using rule 32 (stmt -> DO stmt WHILE ( cexpr ) ; .)
    &               reduce using rule 32 (stmt -> DO stmt WHILE ( cexpr ) ; .)
    -               reduce using rule 32 (stmt -> DO stmt WHILE ( cexpr ) ; .)
    ID              reduce using rule 32 (stmt -> DO stmt WHILE ( cexpr ) ; .)
    (               reduce using rule 32 (stmt -> DO stmt WHILE ( cexpr ) ; .)
    {               reduce using rule 32 (stmt -> DO stmt WHILE ( cexpr ) ; .)
    SCON            reduce using rule 32 (stmt -> DO stmt WHILE ( cexpr ) ; .)
    ICON            reduce using rule 32 (stmt -> DO stmt WHILE ( cexpr ) ; .)
    CCON            reduce using rule 32 (stmt -> DO stmt WHILE ( cexpr ) ; .)
    FCON            reduce using rule 32 (stmt -> DO stmt WHILE ( cexpr ) ; .)
    ELSE            reduce using rule 32 (stmt -> DO stmt WHILE ( cexpr ) ; .)


state 153

    (33) stmt -> FOR ( expro ; cexpro ; expro . ) stmt

    )               shift and go to state 155


state 154

    (30) stmt -> IF ( cexpr ) stmt ELSE stmt .

    }               reduce using rule 30 (stmt -> IF ( cexpr ) stmt ELSE stmt .)
    IF              reduce using rule 30 (stmt -> IF ( cexpr ) stmt ELSE stmt .)
    WHILE           reduce using rule 30 (stmt -> IF ( cexpr ) stmt ELSE stmt .)
    DO              reduce using rule 30 (stmt -> IF ( cexpr ) stmt ELSE stmt .)
    FOR             reduce using rule 30 (stmt -> IF ( cexpr ) stmt ELSE stmt .)
    CONTINUE        reduce using rule 30 (stmt -> IF ( cexpr ) stmt ELSE stmt .)
    BREAK           reduce using rule 30 (stmt -> IF ( cexpr ) stmt ELSE stmt .)
    RETURN          reduce using rule 30 (stmt -> IF ( cexpr ) stmt ELSE stmt .)
    ;               reduce using rule 30 (stmt -> IF ( cexpr ) stmt ELSE stmt .)
    &               reduce using rule 30 (stmt -> IF ( cexpr ) stmt ELSE stmt .)
    -               reduce using rule 30 (stmt -> IF ( cexpr ) stmt ELSE stmt .)
    ID              reduce using rule 30 (stmt -> IF ( cexpr ) stmt ELSE stmt .)
    (               reduce using rule 30 (stmt -> IF ( cexpr ) stmt ELSE stmt .)
    {               reduce using rule 30 (stmt -> IF ( cexpr ) stmt ELSE stmt .)
    SCON            reduce using rule 30 (stmt -> IF ( cexpr ) stmt ELSE stmt .)
    ICON            reduce using rule 30 (stmt -> IF ( cexpr ) stmt ELSE stmt .)
    CCON            reduce using rule 30 (stmt -> IF ( cexpr ) stmt ELSE stmt .)
    FCON            reduce using rule 30 (stmt -> IF ( cexpr ) stmt ELSE stmt .)
    ELSE            reduce using rule 30 (stmt -> IF ( cexpr ) stmt ELSE stmt .)


state 155

    (33) stmt -> FOR ( expro ; cexpro ; expro ) . stmt
    (28) stmt -> . expr ;
    (29) stmt -> . IF ( cexpr ) stmt
    (30) stmt -> . IF ( cexpr ) stmt ELSE stmt
    (31) stmt -> . WHILE ( cexpr ) stmt
    (32) stmt -> . DO stmt WHILE ( cexpr ) ;
    (33) stmt -> . FOR ( expro ; cexpro ; expro ) stmt
    (34) stmt -> . CONTINUE ;
    (35) stmt -> . BREAK ;
    (36) stmt -> . RETURN ;
    (37) stmt -> . RETURN expr ;
    (38) stmt -> . block
    (39) stmt -> . ;
    (56) expr -> . lval = expr
    (57) expr -> . lval ADDEQ expr
    (58) expr -> . lval SUBEQ expr
    (59) expr -> . lval MULEQ expr
    (60) expr -> . lval DIVEQ expr
    (61) expr -> . lval MODEQ expr
    (62) expr -> . expr + expr
    (63) expr -> . expr - expr
    (64) expr -> . expr * expr
    (65) expr -> . expr / expr
    (66) expr -> . expr % expr
    (67) expr -> . expr LSHIFT expr
    (68) expr -> . expr RSHIFT expr
    (69) expr -> . & lval
    (70) expr -> . - expr
    (71) expr -> . lval
    (72) expr -> . ID ( )
    (73) expr -> . ID ( exprs )
    (74) expr -> . ( expr )
    (75) expr -> . constant
    (25) block -> . { stmts }
    (76) lval -> . ID
    (77) lval -> . ID [ expr ]
    (78) constant -> . SCON
    (79) constant -> . ICON
    (80) constant -> . CCON
    (81) constant -> . FCON

    IF              shift and go to state 35
    WHILE           shift and go to state 23
    DO              shift and go to state 21
    FOR             shift and go to state 31
    CONTINUE        shift and go to state 38
    BREAK           shift and go to state 37
    RETURN          shift and go to state 22
    ;               shift and go to state 29
    &               shift and go to state 24
    -               shift and go to state 26
    ID              shift and go to state 34
    (               shift and go to state 25
    {               shift and go to state 41
    SCON            shift and go to state 40
    ICON            shift and go to state 30
    CCON            shift and go to state 28
    FCON            shift and go to state 39

    constant                       shift and go to state 27
    expr                           shift and go to state 36
    stmt                           shift and go to state 156
    lval                           shift and go to state 32
    block                          shift and go to state 43

state 156

    (33) stmt -> FOR ( expro ; cexpro ; expro ) stmt .

    }               reduce using rule 33 (stmt -> FOR ( expro ; cexpro ; expro ) stmt .)
    IF              reduce using rule 33 (stmt -> FOR ( expro ; cexpro ; expro ) stmt .)
    WHILE           reduce using rule 33 (stmt -> FOR ( expro ; cexpro ; expro ) stmt .)
    DO              reduce using rule 33 (stmt -> FOR ( expro ; cexpro ; expro ) stmt .)
    FOR             reduce using rule 33 (stmt -> FOR ( expro ; cexpro ; expro ) stmt .)
    CONTINUE        reduce using rule 33 (stmt -> FOR ( expro ; cexpro ; expro ) stmt .)
    BREAK           reduce using rule 33 (stmt -> FOR ( expro ; cexpro ; expro ) stmt .)
    RETURN          reduce using rule 33 (stmt -> FOR ( expro ; cexpro ; expro ) stmt .)
    ;               reduce using rule 33 (stmt -> FOR ( expro ; cexpro ; expro ) stmt .)
    &               reduce using rule 33 (stmt -> FOR ( expro ; cexpro ; expro ) stmt .)
    -               reduce using rule 33 (stmt -> FOR ( expro ; cexpro ; expro ) stmt .)
    ID              reduce using rule 33 (stmt -> FOR ( expro ; cexpro ; expro ) stmt .)
    (               reduce using rule 33 (stmt -> FOR ( expro ; cexpro ; expro ) stmt .)
    {               reduce using rule 33 (stmt -> FOR ( expro ; cexpro ; expro ) stmt .)
    SCON            reduce using rule 33 (stmt -> FOR ( expro ; cexpro ; expro ) stmt .)
    ICON            reduce using rule 33 (stmt -> FOR ( expro ; cexpro ; expro ) stmt .)
    CCON            reduce using rule 33 (stmt -> FOR ( expro ; cexpro ; expro ) stmt .)
    FCON            reduce using rule 33 (stmt -> FOR ( expro ; cexpro ; expro ) stmt .)
    ELSE            reduce using rule 33 (stmt -> FOR ( expro ; cexpro ; expro ) stmt .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ELSE in state 148 resolved as shift
